<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moodly â€” Track Your Days</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;500;600;700&family=Nunito:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --mood-1: #7B8CDE;
            --mood-2: #A8D5E5;
            --mood-3: #F5E6A3;
            --mood-4: #FFCB8E;
            --mood-5: #FFE066;
            --mood-unset: #E0E0E0;
            --bg-primary: #FFF9F0;
            --bg-secondary: #FFF5E6;
            --text-primary: #4A4A4A;
            --text-secondary: #8A8A8A;
            --accent: #FF9B71;
            --accent-dark: #E8845A;
            --shadow: rgba(255, 155, 113, 0.15);
            --card-bg: #FFFFFF;
            --success: #6BCB77;
            --error: #FF6B6B;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
            overflow-x: hidden;
        }

        /* Decorative background elements */
        .bg-decoration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        }

        .bg-blob {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.4;
            animation: float 20s ease-in-out infinite;
        }

        .bg-blob:nth-child(1) {
            width: 400px;
            height: 400px;
            background: var(--mood-5);
            top: -100px;
            right: -100px;
            animation-delay: 0s;
        }

        .bg-blob:nth-child(2) {
            width: 300px;
            height: 300px;
            background: var(--mood-2);
            bottom: -50px;
            left: -50px;
            animation-delay: -5s;
        }

        .bg-blob:nth-child(3) {
            width: 250px;
            height: 250px;
            background: var(--mood-4);
            top: 50%;
            left: 50%;
            animation-delay: -10s;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) scale(1); }
            25% { transform: translate(30px, -30px) scale(1.05); }
            50% { transform: translate(-20px, 20px) scale(0.95); }
            75% { transform: translate(20px, 10px) scale(1.02); }
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 40px 20px;
            position: relative;
            z-index: 1;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 40px;
        }

        .logo {
            font-family: 'Quicksand', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 8px;
            letter-spacing: -1px;
        }

        .logo span {
            display: inline-block;
            animation: bounce 2s ease-in-out infinite;
        }

        .logo span:nth-child(2) { animation-delay: 0.1s; }
        .logo span:nth-child(3) { animation-delay: 0.2s; }
        .logo span:nth-child(4) { animation-delay: 0.3s; }
        .logo span:nth-child(5) { animation-delay: 0.4s; }
        .logo span:nth-child(6) { animation-delay: 0.5s; }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .tagline {
            color: var(--text-secondary);
            font-size: 1.1rem;
            font-weight: 300;
        }

        /* Auth Section */
        .auth-section {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        .auth-btn {
            padding: 12px 24px;
            border: none;
            background: var(--card-bg);
            border-radius: 20px;
            font-family: 'Quicksand', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .auth-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px var(--shadow);
        }

        .auth-btn.sign-in {
            background: #4285F4;
            color: white;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--card-bg);
            padding: 8px 16px 8px 8px;
            border-radius: 24px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }

        .user-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
        }

        .user-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .sign-out-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 8px;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .sign-out-btn:hover {
            background: var(--bg-secondary);
            color: var(--accent);
        }

        .sync-status {
            font-size: 0.75rem;
            color: var(--success);
            margin-top: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .sync-icon {
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Auth Modal */
        .auth-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s;
        }

        .auth-modal.show {
            display: flex;
        }

        .auth-content {
            background: var(--card-bg);
            border-radius: 24px;
            padding: 40px;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: slideUp 0.4s;
        }

        .auth-title {
            font-family: 'Quicksand', sans-serif;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 12px;
            text-align: center;
        }

        .auth-description {
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 32px;
            line-height: 1.6;
        }

        .google-sign-in-btn {
            width: 100%;
            padding: 16px;
            border: none;
            background: #4285F4;
            color: white;
            border-radius: 16px;
            font-family: 'Quicksand', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            box-shadow: 0 4px 15px rgba(66, 133, 244, 0.3);
        }

        .google-sign-in-btn:hover {
            background: #3367D6;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(66, 133, 244, 0.4);
        }

        .google-icon {
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 4px;
            padding: 2px;
        }

        .skip-btn {
            width: 100%;
            margin-top: 16px;
            padding: 12px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            border-radius: 12px;
            font-family: 'Quicksand', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .skip-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        /* Demo Mode Banner */
        .demo-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            text-align: center;
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            z-index: 1001;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .demo-banner-text {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .demo-banner .owner-login-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .demo-banner .owner-login-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        /* Adjust container when demo banner is shown */
        body.demo-mode .container {
            padding-top: 60px;
        }

        body.demo-mode .auth-section {
            top: 60px;
        }

        body.demo-mode .bg-decoration {
            top: 40px;
        }

        /* Waitlist Modal */
        .waitlist-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s;
        }

        .waitlist-modal.show {
            display: flex;
        }

        .waitlist-content {
            background: var(--card-bg);
            border-radius: 32px;
            padding: 48px 40px;
            max-width: 480px;
            width: 90%;
            box-shadow: 0 25px 80px rgba(0,0,0,0.3);
            animation: slideUp 0.4s;
            text-align: center;
            position: relative;
        }

        .waitlist-close {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .waitlist-close:hover {
            background: var(--error);
            color: white;
            transform: rotate(90deg);
        }

        .waitlist-emoji {
            font-size: 4rem;
            margin-bottom: 16px;
            animation: bounce 2s ease-in-out infinite;
        }

        .waitlist-title {
            font-family: 'Quicksand', sans-serif;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 12px;
        }

        .waitlist-description {
            color: var(--text-secondary);
            font-size: 1.05rem;
            line-height: 1.6;
            margin-bottom: 28px;
        }

        .waitlist-form {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .waitlist-input {
            width: 100%;
            padding: 16px 20px;
            border: 2px solid var(--bg-secondary);
            border-radius: 16px;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            color: var(--text-primary);
            background: var(--bg-secondary);
            transition: all 0.3s;
        }

        .waitlist-input:focus {
            outline: none;
            border-color: var(--accent);
            background: white;
        }

        .waitlist-input::placeholder {
            color: var(--text-secondary);
        }

        .waitlist-submit {
            width: 100%;
            padding: 16px;
            border: none;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
            color: white;
            border-radius: 16px;
            font-family: 'Quicksand', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 155, 113, 0.4);
        }

        .waitlist-submit:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 155, 113, 0.5);
        }

        .waitlist-submit:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }

        .waitlist-message {
            margin-top: 16px;
            font-size: 0.95rem;
            font-weight: 600;
            min-height: 24px;
        }

        .waitlist-message.success {
            color: var(--success);
        }

        .waitlist-message.error {
            color: var(--error);
        }

        .waitlist-privacy {
            margin-top: 20px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* Waitlist button in demo banner */
        .demo-banner .waitlist-btn {
            background: rgba(255,255,255,0.95);
            border: none;
            color: #667eea;
            padding: 6px 16px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .demo-banner .waitlist-btn:hover {
            background: white;
            transform: scale(1.05);
        }

        /* Success state animation */
        @keyframes checkmark {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .waitlist-success-icon {
            display: inline-block;
            animation: checkmark 0.5s ease-out;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 32px;
        }

        .tab-btn {
            padding: 14px 32px;
            border: none;
            background: var(--card-bg);
            border-radius: 20px;
            font-family: 'Quicksand', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }

        .tab-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px var(--shadow);
        }

        .tab-btn.active {
            background: var(--accent);
            color: white;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.4s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Calendar Card */
        .calendar-card {
            background: var(--card-bg);
            border-radius: 32px;
            padding: 32px;
            box-shadow: 0 20px 60px var(--shadow), 0 4px 20px rgba(0,0,0,0.03);
            animation: slideUp 0.6s ease-out;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Month Navigation */
        .month-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 32px;
        }

        .month-title {
            font-family: 'Quicksand', sans-serif;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .nav-btn {
            width: 48px;
            height: 48px;
            border: none;
            background: var(--bg-secondary);
            border-radius: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            font-size: 1.2rem;
            color: var(--text-primary);
        }

        .nav-btn:hover {
            background: var(--accent);
            color: white;
            transform: scale(1.05);
        }

        /* Calendar Grid */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 12px;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }

        .day-header {
            text-align: center;
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.9rem;
            padding: 12px 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .day {
            aspect-ratio: 1;
            background: var(--bg-secondary);
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            padding: 8px;
            min-width: 0; /* Allow flexbox shrinking */
            overflow: hidden;
        }

        .day:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px var(--shadow);
        }

        .day.today {
            border: 3px solid var(--accent);
        }

        .day.other-month {
            opacity: 0.3;
            cursor: default;
        }

        .day.other-month:hover {
            transform: none;
            box-shadow: none;
        }

        .day-number {
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .day-mood {
            font-size: 1.8rem;
            line-height: 1;
        }

        .day.has-mood {
            animation: pulse 0.5s ease;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Mood colors for calendar days */
        .day[data-mood="1"] { background: var(--mood-1); color: white; }
        .day[data-mood="2"] { background: var(--mood-2); color: var(--text-primary); }
        .day[data-mood="3"] { background: var(--mood-3); color: var(--text-primary); }
        .day[data-mood="4"] { background: var(--mood-4); color: var(--text-primary); }
        .day[data-mood="5"] { background: var(--mood-5); color: var(--text-primary); }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 999;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--card-bg);
            border-radius: 32px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 30px 80px rgba(0,0,0,0.3);
            animation: slideUp 0.4s;
        }

        .modal-header {
            text-align: center;
            margin-bottom: 32px;
        }

        .modal-date {
            font-family: 'Quicksand', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 8px;
        }

        .modal-subtitle {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .mood-section, .detail-section {
            margin-bottom: 32px;
        }

        .section-title {
            font-family: 'Quicksand', sans-serif;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 16px;
        }

        .mood-options {
            display: flex;
            justify-content: space-between;
            gap: 12px;
        }

        .mood-option {
            flex: 1;
            padding: 20px 12px;
            border: 3px solid transparent;
            background: var(--bg-secondary);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }

        .mood-option:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px var(--shadow);
        }

        .mood-option.selected {
            border-color: var(--accent);
            background: white;
            transform: translateY(-4px);
        }

        .mood-emoji {
            font-size: 2.5rem;
            line-height: 1;
        }

        .mood-label {
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .detail-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }

        .detail-option {
            padding: 16px;
            border: 2px solid transparent;
            background: var(--bg-secondary);
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
        }

        .detail-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px var(--shadow);
        }

        .detail-option.selected {
            border-color: var(--accent);
            background: white;
        }

        .detail-emoji {
            font-size: 1.8rem;
            line-height: 1;
        }

        .detail-label {
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        /* Settings Styles */
        .settings-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .settings-section {
            background: var(--card-bg);
            border-radius: 24px;
            padding: 28px;
            margin-bottom: 24px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }

        .settings-title {
            font-family: 'Quicksand', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-subtitle {
            font-family: 'Quicksand', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 16px;
            margin-top: 24px;
        }

        .settings-info {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 16px;
            margin-bottom: 16px;
        }

        .settings-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
        }

        .settings-user-details {
            flex: 1;
        }

        .settings-user-name {
            font-weight: 700;
            font-size: 1.2rem;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .settings-user-email {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .settings-user-status {
            display: inline-block;
            padding: 4px 12px;
            background: var(--success);
            color: white;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-top: 8px;
        }

        .settings-user-status.anonymous {
            background: var(--text-secondary);
        }

        .login-prompt {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .login-prompt-icon {
            font-size: 3rem;
            margin-bottom: 16px;
        }

        .login-prompt-text {
            font-size: 1.1rem;
            margin-bottom: 20px;
        }

        .category-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 12px;
            margin-bottom: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .category-toggle:hover {
            background: #FFE9D9;
        }

        .category-toggle-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .category-toggle-emoji {
            font-size: 1.5rem;
        }

        .category-toggle-label {
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            color: var(--text-primary);
        }

        .toggle-switch {
            width: 50px;
            height: 26px;
            background: var(--mood-unset);
            border-radius: 13px;
            position: relative;
            transition: all 0.3s;
        }

        .toggle-switch.active {
            background: var(--accent);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }

        .toggle-switch.active::after {
            left: 26px;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .custom-option {
            padding: 14px;
            border: 2px solid var(--bg-secondary);
            background: white;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
            position: relative;
        }

        .custom-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px var(--shadow);
        }

        .custom-option.selected {
            border-color: var(--accent);
            background: #FFF5F0;
        }

        .custom-option:not(.selected) {
            opacity: 0.5;
        }

        .custom-option.default {
            /* Default options have the same style as custom ones */
        }

        .custom-option .edit-btn {
            position: absolute;
            top: 4px;
            left: 4px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 0.8rem;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .custom-option:hover .edit-btn {
            display: flex;
        }

        .custom-option .edit-btn:hover {
            transform: scale(1.1);
            background: #FFB347;
        }

        .custom-option .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--error);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 0.7rem;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .custom-option:hover .remove-btn {
            display: flex;
        }

        .custom-option .remove-btn:hover {
            transform: scale(1.1);
        }

        .add-option-btn {
            padding: 14px;
            border: 2px dashed var(--accent);
            background: transparent;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
            justify-content: center;
            color: var(--accent);
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .add-option-btn:hover {
            background: #FFF5F0;
            transform: translateY(-2px);
        }

        .add-option-icon {
            font-size: 1.8rem;
        }

        .custom-option-form {
            display: none;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 12px;
            margin-bottom: 16px;
        }

        .custom-option-form.show {
            display: block;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            display: block;
        }

        .form-input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--bg-secondary);
            border-radius: 12px;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            background: white;
            transition: all 0.3s;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .emoji-picker {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 8px;
            margin-top: 8px;
        }

        .emoji-option {
            font-size: 1.8rem;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .emoji-option:hover {
            background: white;
            transform: scale(1.1);
        }

        .emoji-option.selected {
            background: white;
            border-color: var(--accent);
        }

        .form-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .form-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .form-btn.cancel {
            background: var(--mood-unset);
            color: var(--text-primary);
        }

        .form-btn.save {
            background: var(--accent);
            color: white;
        }

        .form-btn:hover {
            transform: translateY(-2px);
        }

        .save-settings-btn {
            width: 100%;
            padding: 16px;
            border: none;
            background: var(--accent);
            color: white;
            border-radius: 16px;
            font-family: 'Quicksand', sans-serif;
            font-weight: 700;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 24px;
        }

        .save-settings-btn:hover {
            background: var(--accent-dark);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--shadow);
        }

        /* Emoji Picker Modal */
        .emoji-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .emoji-modal.show {
            display: flex;
        }

        .emoji-modal-content {
            background: var(--card-bg);
            border-radius: 24px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 600px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .emoji-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .emoji-modal-title {
            font-family: 'Quicksand', sans-serif;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .emoji-modal-close {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .emoji-modal-close:hover {
            background: var(--error);
            color: white;
            transform: rotate(90deg);
        }

        .emoji-grid-container {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            border: 2px solid var(--bg-secondary);
            border-radius: 12px;
        }

        .emoji-category-section {
            margin-bottom: 20px;
        }

        .emoji-category-title {
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            font-size: 0.9rem;
            position: sticky;
            top: 0;
            background: var(--card-bg);
            padding: 8px 0;
            z-index: 1;
        }

        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 8px;
        }

        .emoji-item {
            font-size: 2rem;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            border: 2px solid transparent;
            background: var(--bg-secondary);
        }

        .emoji-item:hover {
            background: white;
            transform: scale(1.2);
        }

        .emoji-item.selected {
            background: white;
            border-color: var(--accent);
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            .emoji-grid {
                grid-template-columns: repeat(6, 1fr);
            }

            .emoji-item {
                font-size: 1.5rem;
            }
        }

        @media (max-width: 480px) {
            .emoji-grid {
                grid-template-columns: repeat(5, 1fr);
            }
        }

        .note-section {
            margin-bottom: 32px;
        }

        .note-input {
            width: 100%;
            min-height: 100px;
            padding: 16px;
            border: 2px solid var(--bg-secondary);
            border-radius: 16px;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            color: var(--text-primary);
            background: var(--bg-secondary);
            resize: vertical;
            transition: all 0.3s;
        }

        .note-input:focus {
            outline: none;
            border-color: var(--accent);
            background: white;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .btn {
            padding: 14px 32px;
            border: none;
            border-radius: 16px;
            font-family: 'Quicksand', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-cancel {
            background: var(--bg-secondary);
            color: var(--text-secondary);
        }

        .btn-cancel:hover {
            background: var(--mood-unset);
            color: var(--text-primary);
        }

        .btn-save {
            background: var(--accent);
            color: white;
        }

        .btn-save:hover {
            background: var(--accent-dark);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--shadow);
        }

        /* Analytics Section */
        .analytics-header {
            background: var(--card-bg);
            border-radius: 24px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .date-range {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            width: 100%;
        }

        .date-input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .date-input-group label {
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .date-input-group input {
            padding: 12px;
            border: 2px solid var(--bg-secondary);
            border-radius: 12px;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            color: var(--text-primary);
            width: 100%;
        }

        .date-input-group input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .apply-btn {
            padding: 12px 24px;
            border: none;
            background: var(--accent);
            color: white;
            border-radius: 12px;
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 24px;
        }

        .apply-btn:hover {
            background: var(--accent-dark);
            transform: translateY(-2px);
        }

        .export-btn {
            padding: 12px 24px;
            border: 2px solid var(--accent);
            background: white;
            color: var(--accent);
            border-radius: 12px;
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 24px;
        }

        .export-btn:hover {
            background: var(--accent);
            color: white;
            transform: translateY(-2px);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
        }

        .stat-card {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 24px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            text-align: center;
            transition: all 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px var(--shadow);
        }

        .stat-value {
            font-family: 'Quicksand', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 8px;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .info-icon {
            cursor: help;
            font-size: 0.85em;
            opacity: 0.6;
            transition: opacity 0.2s ease;
            margin-left: 4px;
            display: inline-block;
            position: relative;
        }

        .info-icon:hover,
        .info-icon:focus {
            opacity: 1;
            outline: none;
        }

        /* Mobile: Show tooltip on click/tap */
        @media (hover: none) {
            .info-icon {
                opacity: 0.8;
            }
            
            .info-icon:active {
                opacity: 1;
            }
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 24px;
        }
        
        /* Two-column span for featured charts on laptop/desktop */
        @media (min-width: 1024px) {
            .charts-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .chart-card-wide {
                grid-column: span 2;
            }
        }

        .chart-card {
            background: var(--card-bg);
            border-radius: 24px;
            padding: 24px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        
        /* Add spacing between charts in Record tab */
        #recordTab .chart-card {
            margin-bottom: 30px;
        }

        .chart-title {
            font-family: 'Quicksand', sans-serif;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chart-title-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }
        
        .chart-title .info-icon {
            order: 2;
        }
        
        .chart-title .chart-modify-btn {
            order: 1;
        }

        .chart-delete-mode-btn {
            background: transparent;
            border: 2px solid var(--error);
            color: var(--error);
            border-radius: 8px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            opacity: 0.8;
        }

        .chart-modify-btn {
            background: transparent;
            border: 2px solid var(--accent);
            color: var(--accent);
            border-radius: 8px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            opacity: 0.8;
            font-weight: 600;
        }

        .chart-modify-btn:hover {
            opacity: 1;
            background: var(--accent);
            color: white;
            transform: scale(1.05);
        }

        .chart-modify-btn.active {
            background: var(--accent);
            color: white;
            opacity: 1;
            box-shadow: 0 4px 12px rgba(255, 155, 113, 0.3);
        }

        .period-btn {
            background: var(--bg-secondary);
            border: 2px solid transparent;
            color: var(--text-secondary);
            border-radius: 8px;
            padding: 4px 12px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .period-btn:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .period-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            box-shadow: 0 2px 8px rgba(255, 155, 113, 0.3);
        }

        .chart-modify-info {
            background: #FFF5E6;
            border: 2px solid #FF8C42;
            border-radius: 12px;
            padding: 12px 16px;
            margin-bottom: 16px;
            color: #D65108;
            font-weight: 600;
            text-align: center;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .chart-container {
            position: relative;
            height: 300px;
            max-width: 100%;
            overflow: hidden;
        }
        
        /* Dynamic height charts for Record tab Lift and Correlation - handled by JS */
        #liftChartContainer, #correlationChartContainer {
            min-height: 350px;
        }
        
        /* Make sure parent containers work with dynamic sizing */
        #recordTab .chart-container {
            height: 300px;
        }
        
        @media (max-width: 768px) {
            .chart-container {
                height: 250px;
                margin: 0 -10px; /* Extend to edges on mobile */
            }
            
            .chart-card {
                padding: 15px 10px; /* Reduce padding on mobile */
            }
            
            #liftChartContainer, #correlationChartContainer {
                min-height: 300px;
            }
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--success);
            color: white;
            padding: 16px 28px;
            border-radius: 16px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            font-family: 'Quicksand', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            z-index: 10000;
            opacity: 0;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .toast.error {
            background: var(--error);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .logo {
                font-size: 2rem;
            }

            .calendar-grid {
                gap: 4px;
            }

            .day {
                border-radius: 12px;
                padding: 4px;
            }

            .day-header {
                font-size: 0.75rem;
                padding: 8px 0;
            }

            .day-mood {
                font-size: 1.2rem;
            }

            .day-number {
                font-size: 0.8rem;
            }

            .modal {
                padding: 24px;
            }

            .mood-options {
                gap: 8px;
            }

            .mood-option {
                padding: 16px 8px;
            }

            .mood-emoji {
                font-size: 2rem;
            }

            .detail-options,
            .options-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }

            .charts-grid {
                grid-template-columns: 1fr;
            }

            .auth-section {
                position: static;
                margin-bottom: 20px;
                display: flex;
                justify-content: center;
            }

            .tab-nav {
                flex-wrap: wrap;
            }

            .tab-btn {
                padding: 12px 20px;
                font-size: 0.9rem;
            }

            .emoji-picker {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 20px 10px;
            }

            .calendar-card {
                padding: 16px;
                border-radius: 24px;
            }

            .calendar-grid {
                gap: 2px;
            }

            .day {
                border-radius: 8px;
                padding: 2px;
            }

            .month-title {
                font-size: 1.3rem;
            }

            .day-number {
                font-size: 0.8rem;
            }

            .day-mood {
                font-size: 1.2rem;
            }

            .nav-btn {
                width: 40px;
                height: 40px;
            }

            .detail-options,
            .options-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .emoji-picker {
                grid-template-columns: repeat(5, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="bg-decoration">
        <div class="bg-blob"></div>
        <div class="bg-blob"></div>
        <div class="bg-blob"></div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <!-- Demo Mode Banner -->
    <div class="demo-banner" id="demoBanner" style="display: none;">
        <div class="demo-banner-text">
            <span>ðŸŽ®</span>
            <span>Demo Mode â€” Explore freely! Your changes won't be saved.</span>
        </div>
        <button class="waitlist-btn" id="waitlistBannerBtn">
            <span>âœ‰ï¸</span>
            <span>Get Notified</span>
        </button>
        <button class="owner-login-btn" id="ownerLoginBtn">Owner Login</button>
    </div>

    <!-- Waitlist Modal -->
    <div class="waitlist-modal" id="waitlistModal">
        <div class="waitlist-content">
            <button class="waitlist-close" id="waitlistClose">Ã—</button>
            <div class="waitlist-emoji">ðŸš€</div>
            <h2 class="waitlist-title">Coming Soon!</h2>
            <p class="waitlist-description">
                Moodly is launching soon. Be the first to know when we go live and get early access to track your moods!
            </p>
            <form class="waitlist-form" id="waitlistForm">
                <input 
                    type="email" 
                    class="waitlist-input" 
                    id="waitlistEmail" 
                    placeholder="Enter your email address" 
                    required
                >
                <button type="submit" class="waitlist-submit" id="waitlistSubmit">
                    Notify Me ðŸ””
                </button>
            </form>
            <p class="waitlist-message" id="waitlistMessage"></p>
            <p class="waitlist-privacy">ðŸ”’ We respect your privacy. No spam, ever.</p>
        </div>
    </div>

    <div class="auth-section" id="authSection"></div>

    <!-- Auth Modal -->
    <div class="auth-modal" id="authModal">
        <div class="auth-content">
            <div class="auth-title">ðŸ”’ Sync Your Moods</div>
            <div class="auth-description">
                Sign in with Google to save your mood data across all your devices. Your data stays private and secure.
            </div>
            <button class="google-sign-in-btn" id="googleSignInBtn">
                <svg class="google-icon" viewBox="0 0 24 24">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Continue with Google
            </button>
            <button class="skip-btn" id="skipAuthBtn">Continue without signing in</button>
        </div>
    </div>

    <div class="container">
        <header>
            <h1 class="logo">
                <span>M</span><span>o</span><span>o</span><span>d</span><span>l</span><span>y</span>
            </h1>
            <p class="tagline">Track your daily moods and discover patterns âœ¨</p>
        </header>

        <div class="tab-nav">
            <button class="tab-btn active" data-tab="calendar">ðŸ“… Calendar</button>
            <button class="tab-btn" data-tab="analytics">ðŸ“Š Mood</button>
            <button class="tab-btn" data-tab="sleep">ðŸ˜´ Sleep</button>
            <button class="tab-btn" data-tab="record">ðŸ” Record</button>
            <button class="tab-btn" data-tab="settings">âš™ï¸ Settings</button>
        </div>

        <div id="calendarTab" class="tab-content active">
            <div class="calendar-card">
                <div class="month-nav">
                    <button class="nav-btn" id="prevMonth">â†</button>
                    <h2 class="month-title" id="monthTitle">January 2024</h2>
                    <button class="nav-btn" id="nextMonth">â†’</button>
                </div>
                <div class="calendar-grid" id="calendar"></div>
            </div>
        </div>

        <div id="analyticsTab" class="tab-content">
            <div class="analytics-header">
                <div class="date-range">
                    <div class="date-input-group">
                        <label>Start Date</label>
                        <input type="date" id="startDate">
                    </div>
                    <div class="date-input-group">
                        <label>End Date</label>
                        <input type="date" id="endDate">
                    </div>
                    <div class="date-input-group">
                        <label>
                            Significance Level
                            <span class="info-icon" style="cursor: pointer; margin-left: 5px;" title="Filter results by statistical significance. Each chart uses a different statistical test appropriate for its data type. Check the â„¹ï¸ icon on each chart for details about which test is used.">â„¹ï¸</span>
                        </label>
                        <select id="significanceLevel" style="padding: 8px 12px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary); font-size: 14px;">
                            <option value="none" selected>None (Original View)</option>
                            <option value="0.05">High (p<0.05)</option>
                            <option value="0.1">Medium (p<0.1)</option>
                            <option value="0.2">Low (p<0.2)</option>
                        </select>
                    </div>
                </div>
                <button class="apply-btn" id="applyDateRange">Apply Range</button>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="totalDays">0</div>
                    <div class="stat-label">Days Tracked</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgMood">0.0</div>
                    <div class="stat-label">Average Mood</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="bestDay">â€”</div>
                    <div class="stat-label">Best Month</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="moodConsistencyStat">â€”</div>
                    <div class="stat-label">
                        Mood Consistency
                        <span class="info-icon" tabindex="0" role="button" aria-label="Info about mood consistency" title="Mood Consistency Score: Measures deviation from your 7-day average mood. ðŸŸ¢ Green (90-100%): â‰¤0.5 deviation, ðŸŸ¡ Yellow (60-89%): 0.5-1.5 deviation, ðŸ”´ Red (0-59%): >1.5 deviation. Lower deviation = more stable mood.">â„¹ï¸</span>
                    </div>
                </div>
            </div>

            <div class="charts-grid">
                <!-- 1. Mood Trend (wide) -->
                <div class="chart-card chart-card-wide">
                    <h3 class="chart-title">Mood Trend</h3>
                    <div class="chart-container">
                        <canvas id="moodTrendChart"></canvas>
                    </div>
                </div>
                
                <!-- 2. Mood by Day -->
                <div class="chart-card">
                    <h3 class="chart-title">Mood by Day</h3>
                    <div class="chart-container">
                        <canvas id="moodDayChart"></canvas>
                    </div>
                </div>
                
                <!-- 3. Mood Distribution -->
                <div class="chart-card">
                    <h3 class="chart-title">Mood Distribution</h3>
                    <div class="chart-container">
                        <canvas id="moodDistChart"></canvas>
                    </div>
                </div>
                
                <!-- 4. Activity Impact -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Activity Impact
                        <span class="chart-title-buttons">
                            <button class="chart-modify-btn" onclick="toggleChartModifyMode('activity')" title="Modify chart data">âœï¸ Modify</button>
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about statistical test" title="Statistical Test: Mann-Whitney U Test. A non-parametric test that compares mood rankings when this activity is present vs. absent. Tests whether doing this activity is associated with significantly different mood levels.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div id="activityChartModifyInfo" class="chart-modify-info" style="display: none;">
                        âš ï¸ Modify Mode: Click on any bar to delete that activity. This action cannot be undone!
                    </div>
                    <div class="chart-container">
                        <canvas id="activityChart"></canvas>
                    </div>
                </div>
                
                <!-- 5. Social Impact -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Social Impact
                        <span class="chart-title-buttons">
                            <button class="chart-modify-btn" onclick="toggleChartModifyMode('social')" title="Modify chart data">âœï¸ Modify</button>
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about statistical test" title="Statistical Test: Mann-Whitney U Test. A non-parametric test that compares mood rankings when with this person/group vs. not. Tests whether being with certain people is associated with significantly different mood levels.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div id="socialChartModifyInfo" class="chart-modify-info" style="display: none;">
                        âš ï¸ Modify Mode: Click on any bar to delete that person/group. This action cannot be undone!
                    </div>
                    <div class="chart-container">
                        <canvas id="socialChart"></canvas>
                    </div>
                </div>
                
                <!-- 6. Weather & Mood -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Weather & Mood
                        <span class="chart-title-buttons">
                            <button class="chart-modify-btn" onclick="toggleChartModifyMode('weather')" title="Modify chart data">âœï¸ Modify</button>
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about statistical test" title="Statistical Test: Mann-Whitney U Test. A non-parametric test that compares mood rankings on days with this weather vs. other days. Tests whether certain weather conditions are associated with significantly different mood levels.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div id="weatherChartModifyInfo" class="chart-modify-info" style="display: none;">
                        âš ï¸ Modify Mode: Click on any bar to delete that weather. This action cannot be undone!
                    </div>
                    <div class="chart-container">
                        <canvas id="moodWeatherChart"></canvas>
                    </div>
                </div>
                
                <!-- 7. Factors & Mood -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Factors & Mood
                        <span class="chart-title-buttons">
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about statistical test" title="Statistical Test: Mann-Whitney U Test. A non-parametric test that compares mood rankings when this factor is present vs. absent. Tests whether certain factors are associated with significantly different mood levels.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div class="chart-container">
                        <canvas id="factorsChart"></canvas>
                    </div>
                </div>
                
                <!-- 8. Mood Consistency Score -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Mood Consistency Score
                        <span class="chart-title-buttons">
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about mood consistency" title="Mood Consistency Score: Measures deviation from your 7-day average mood. ðŸŸ¢ Green (90-100%): â‰¤0.5 deviation, ðŸŸ¡ Yellow (60-89%): 0.5-1.5 deviation, ðŸ”´ Red (0-59%): >1.5 deviation. Lower deviation = more stable mood.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div class="chart-container" style="display: flex; justify-content: center; align-items: center; padding: 20px;">
                        <div style="width: 300px; max-width: 100%;">
                            <canvas id="moodConsistencyGauge"></canvas>
                        </div>
                    </div>
                </div>
                
                <!-- 9. Mood Consistency Trend -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Mood Consistency Trend
                        <div style="display: inline-flex; gap: 5px; margin-left: 15px;">
                            <button class="period-btn" data-period="daily" onclick="updateMoodConsistencyPeriod('daily')">Daily</button>
                            <button class="period-btn active" data-period="weekly" onclick="updateMoodConsistencyPeriod('weekly')">Weekly</button>
                            <button class="period-btn" data-period="monthly" onclick="updateMoodConsistencyPeriod('monthly')">Monthly</button>
                        </div>
                    </h3>
                    <div class="chart-container">
                        <canvas id="moodConsistencyChart"></canvas>
                    </div>
                </div>
                
                <!-- 10. What Happens Before Bad Moods -->
                <div class="chart-card chart-card-wide">
                    <h3 class="chart-title">
                        What Happens on Days Before a Bad Mood?
                        <span class="chart-title-buttons">
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about bad mood predictors" title="Statistical Test: Two-Proportion Z-Test. Compares the proportion of each factor on days before bad moods (â‰¤3) vs. all days. Tests Hâ‚€: pâ‚=pâ‚‚ (proportions are equal) vs. Hâ‚: pâ‚â‰ pâ‚‚ (proportions differ). Faded bars indicate non-significant differences.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div id="badMoodPredictorsInfo" style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 8px; margin-bottom: 12px; line-height: 1.6;">
                        <div>ðŸ“Š Shows difference from normal for the day <strong>before</strong> a bad mood (â‰¤3)</div>
                        <div style="margin-top: 4px;">
                            <span style="color: #ef4444;">â– </span> Red bars = higher than normal (potential warning signs)
                            <span style="margin-left: 15px; color: #22c55e;">â– </span> Green bars = lower than normal (missing protective factors)
                        </div>
                    </div>
                    <div class="chart-container" id="badMoodPredictorsContainer" style="min-height: 350px;">
                        <canvas id="badMoodPredictorsChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div id="sleepTab" class="tab-content">
            <div class="analytics-header">
                <div class="date-range">
                    <div class="date-input-group">
                        <label>Start Date</label>
                        <input type="date" id="sleepStartDate">
                    </div>
                    <div class="date-input-group">
                        <label>End Date</label>
                        <input type="date" id="sleepEndDate">
                    </div>
                    <div class="date-input-group">
                        <label>
                            Significance Level
                            <span class="info-icon" style="cursor: pointer; margin-left: 5px;" title="Uses Mann-Whitney U test - a non-parametric test appropriate for ordinal data like mood ratings. Compares whether one category tends to have different mood rankings than others.">â„¹ï¸</span>
                        </label>
                        <select id="sleepSignificanceLevel" style="padding: 8px 12px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary); font-size: 14px;">
                            <option value="none" selected>None (Original View)</option>
                            <option value="0.05">High (p<0.05)</option>
                            <option value="0.1">Medium (p<0.1)</option>
                            <option value="0.2">Low (p<0.2)</option>
                        </select>
                    </div>
                </div>
                <button class="apply-btn" id="applySleepDateRange">Apply Range</button>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="avgSleepDuration">0</div>
                    <div class="stat-label">Avg Sleep Duration (hrs)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgSleepTime">--:--</div>
                    <div class="stat-label">Avg Sleep Time</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgWakeTime">--:--</div>
                    <div class="stat-label">Avg Wake Time</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="sleepConsistency">0%</div>
                    <div class="stat-label">
                        Sleep Consistency
                        <span class="info-icon" tabindex="0" role="button" aria-label="Info about sleep consistency" title="Sleep Consistency Score: Measures average deviation of bedtime and wake time from your 7-day average. ðŸŸ¢ Green (90-100%): 0-30 min deviation, ðŸŸ¡ Yellow (60-89%): 31-90 min deviation, ðŸ”´ Red (0-59%): >90 min deviation. Lower deviation = higher score.">â„¹ï¸</span>
                    </div>
                </div>
            </div>

            <div class="charts-grid">
                <!-- 1. Sleep Schedule (wide) -->
                <div class="chart-card chart-card-wide">
                    <h3 class="chart-title">Sleep Schedule</h3>
                    <div class="chart-container">
                        <canvas id="sleepScheduleChartSleep"></canvas>
                    </div>
                </div>
                
                <!-- 2. Sleep Duration vs Mood (Hourly) -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Sleep Duration vs Mood (Hourly)
                        <span class="chart-title-buttons">
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about statistical test" title="Statistical Test: Mann-Whitney U Test. A non-parametric test that compares mood rankings for each hourly sleep duration bucket vs. all other days. Tests whether specific sleep durations are associated with significantly different mood levels.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div class="chart-container">
                        <canvas id="sleepDurationChart"></canvas>
                    </div>
                </div>
                
                <!-- 3. Sleep Duration Category vs Mood -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Sleep Duration Category vs Mood
                        <span class="chart-title-buttons">
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about statistical test" title="Statistical Test: Mann-Whitney U Test. A non-parametric test that compares mood rankings for each sleep duration category vs. all other days. Tests whether sleeping a certain amount is associated with significantly different mood levels.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div class="chart-container">
                        <canvas id="sleepDurationCategoryChart"></canvas>
                    </div>
                </div>
                
                <!-- 4. Sleep Time Category vs Mood -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Sleep Time Category vs Mood
                        <span class="chart-title-buttons">
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about statistical test" title="Statistical Test: Mann-Whitney U Test. A non-parametric test that compares mood rankings for each bedtime category vs. all other days. Tests whether going to bed at certain times is associated with significantly different mood levels.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div class="chart-container">
                        <canvas id="sleepTimeCategoryChart"></canvas>
                    </div>
                </div>
                
                <!-- 5. Wake Time Category vs Mood -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Wake Time Category vs Mood
                        <span class="chart-title-buttons">
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about statistical test" title="Statistical Test: Mann-Whitney U Test. A non-parametric test that compares mood rankings for each wake time category vs. all other days. Tests whether waking up at certain times is associated with significantly different mood levels.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div class="chart-container">
                        <canvas id="wakeTimeCategoryChart"></canvas>
                    </div>
                </div>
                
                <!-- 6. Sleep Consistency Score -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Sleep Consistency Score
                        <span class="chart-title-buttons">
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about sleep consistency calculation" title="Sleep Consistency Score: Measures average deviation of bedtime and wake time from your 7-day average. ðŸŸ¢ Green (90-100%): 0-30 min deviation, ðŸŸ¡ Yellow (60-89%): 31-90 min deviation, ðŸ”´ Red (0-59%): >90 min deviation. Lower deviation = higher score.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div class="chart-container" style="display: flex; justify-content: center; align-items: center; padding: 20px;">
                        <div style="width: 300px; max-width: 100%;">
                            <canvas id="sleepConsistencyGauge"></canvas>
                        </div>
                    </div>
                </div>
                
                <!-- 7. Sleep Consistency Trend -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Sleep Consistency Trend
                        <div style="display: inline-flex; gap: 5px; margin-left: 15px;">
                            <button class="period-btn" data-period="daily" onclick="updateConsistencyPeriod('daily')">Daily</button>
                            <button class="period-btn active" data-period="weekly" onclick="updateConsistencyPeriod('weekly')">Weekly</button>
                            <button class="period-btn" data-period="monthly" onclick="updateConsistencyPeriod('monthly')">Monthly</button>
                        </div>
                    </h3>
                    <div class="chart-container">
                        <canvas id="sleepConsistencyChart"></canvas>
                    </div>
                </div>
                
                <!-- 8. Sleep Time Consistency Trend -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Sleep Time Consistency Trend
                        <div style="display: inline-flex; gap: 5px; margin-left: 15px;">
                            <button class="period-btn" data-period="daily" onclick="updateSleepTimeConsistencyPeriod('daily')">Daily</button>
                            <button class="period-btn active" data-period="weekly" onclick="updateSleepTimeConsistencyPeriod('weekly')">Weekly</button>
                            <button class="period-btn" data-period="monthly" onclick="updateSleepTimeConsistencyPeriod('monthly')">Monthly</button>
                        </div>
                    </h3>
                    <div class="chart-container">
                        <canvas id="sleepTimeConsistencyChart"></canvas>
                    </div>
                </div>
                
                <!-- 9. Wake Time Consistency Trend -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Wake Time Consistency Trend
                        <div style="display: inline-flex; gap: 5px; margin-left: 15px;">
                            <button class="period-btn" data-period="daily" onclick="updateWakeTimeConsistencyPeriod('daily')">Daily</button>
                            <button class="period-btn active" data-period="weekly" onclick="updateWakeTimeConsistencyPeriod('weekly')">Weekly</button>
                            <button class="period-btn" data-period="monthly" onclick="updateWakeTimeConsistencyPeriod('monthly')">Monthly</button>
                        </div>
                    </h3>
                    <div class="chart-container">
                        <canvas id="wakeTimeConsistencyChart"></canvas>
                    </div>
                </div>
                
                <!-- 10. Sleep Consistency vs Mood -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Sleep Consistency vs Mood
                        <span class="chart-title-buttons">
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about statistical test" title="Statistical Test: Mann-Whitney U Test. A non-parametric test that compares mood rankings for each sleep consistency category vs. all other days. Tests whether consistent sleep schedules are associated with significantly different mood levels.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div class="chart-container">
                        <canvas id="sleepConsistencyVsMoodChart"></canvas>
                    </div>
                </div>
                
                <!-- 11. Sleep Quality vs Mood -->
                <div class="chart-card">
                    <h3 class="chart-title">
                        Sleep Quality vs Mood
                        <span class="chart-title-buttons">
                            <button class="chart-modify-btn" onclick="toggleChartModifyMode('sleepQuality')" title="Modify chart data">âœï¸ Modify</button>
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about statistical test" title="Statistical Test: Mann-Whitney U Test. A non-parametric test that compares mood rankings for each sleep quality rating vs. all other days. Tests whether sleep quality is associated with significantly different mood levels.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div id="sleepQualityChartModifyInfo" class="chart-modify-info" style="display: none;">
                        âš ï¸ Modify Mode: Click on any bar to delete that sleep quality. This action cannot be undone!
                    </div>
                    <div class="chart-container">
                        <canvas id="sleepQualityChartSleep"></canvas>
                    </div>
                </div>
                
                <!-- 12. Sleep Time vs Mood -->
                <div class="chart-card">
                    <h3 class="chart-title">Sleep Time vs Mood</h3>
                    <div class="chart-container">
                        <canvas id="sleepTimeChart"></canvas>
                    </div>
                </div>
                
                <!-- 13. Wake Time vs Mood -->
                <div class="chart-card">
                    <h3 class="chart-title">Wake Time vs Mood</h3>
                    <div class="chart-container">
                        <canvas id="wakeTimeChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div id="recordTab" class="tab-content">
            <div class="analytics-header">
                <div class="date-range">
                    <div class="date-input-group">
                        <label>Start Date</label>
                        <input type="date" id="recordStartDate">
                    </div>
                    <div class="date-input-group">
                        <label>End Date</label>
                        <input type="date" id="recordEndDate">
                    </div>
                    <div class="date-input-group">
                        <label>
                            Select Record
                            <span class="info-icon" style="cursor: pointer; margin-left: 5px;" title="Choose an activity, weather, social, or factor to analyze its relationships with other records.">â„¹ï¸</span>
                        </label>
                        <select id="recordSelection" style="padding: 8px 12px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary); font-size: 14px;">
                            <option value="">Select a record...</option>
                        </select>
                    </div>
                    <div class="date-input-group">
                        <label>
                            Significance Level
                            <span class="info-icon" style="cursor: pointer; margin-left: 5px;" title="Filter results by statistical significance. Uses Chi-square test of independence to determine if two records co-occur more or less than expected by chance. Check chart â„¹ï¸ icons for specific test details.">â„¹ï¸</span>
                        </label>
                        <select id="recordSignificanceLevel" style="padding: 8px 12px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary); font-size: 14px;">
                            <option value="none" selected>None (Original View)</option>
                            <option value="0.05">High (p<0.05)</option>
                            <option value="0.1">Medium (p<0.1)</option>
                            <option value="0.2">Low (p<0.2)</option>
                        </select>
                    </div>
                </div>
                <button class="apply-btn" id="applyRecordRange">Apply</button>
            </div>

            <div id="recordChartsContainer" style="display: none;">
                <!-- Record Distribution -->
                <div class="chart-card">
                    <h3 class="chart-title">Mood Distribution</h3>
                    <div class="chart-container">
                        <canvas id="recordMoodDistChart"></canvas>
                    </div>
                </div>

                <!-- Lift Chart -->
                <div class="chart-card chart-card-wide">
                    <h3 class="chart-title">
                        What Activities Co-occur Together?
                        <span class="chart-title-buttons">
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about Lift Analysis" title="Statistical Test: Lift Analysis. Lift = P(Aâˆ©B) / (P(A)Â·P(B)). Measures how much more likely two records co-occur compared to random chance. Lift > 1: co-occur more than expected. Lift = 1: independent. Lift < 1: co-occur less than expected.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div id="liftChartInfo" style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 8px; margin-bottom: 12px; line-height: 1.6;">
                        <div>ðŸ“Š Shows how often activities happen together compared to random chance</div>
                        <div style="margin-top: 4px;">
                            <span style="color: #22c55e;">â– </span> Green bars = co-occur more than expected (bundled habits)
                            <span style="margin-left: 15px; color: #ef4444;">â– </span> Red bars = co-occur less than expected (competing activities)
                        </div>
                    </div>
                    <div class="chart-container" id="liftChartContainer" style="min-height: 350px;">
                        <canvas id="recordLiftChart"></canvas>
                    </div>
                </div>

                <!-- Correlation Chart -->
                <div class="chart-card chart-card-wide">
                    <h3 class="chart-title">
                        How Strongly Are Activities Related?
                        <span class="chart-title-buttons">
                            <span class="info-icon" tabindex="0" role="button" aria-label="Info about Correlation Analysis" title="Statistical Test: Phi Coefficient (Ï†). Measures association between two binary variables. Values range from -1 (perfect negative) to +1 (perfect positive). Equivalent to Pearson correlation for binary data. Chi-square test determines significance.">â„¹ï¸</span>
                        </span>
                    </h3>
                    <div id="correlationChartInfo" style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 8px; margin-bottom: 12px; line-height: 1.6;">
                        <div>ðŸ“Š Shows statistical correlation between the selected record and others</div>
                        <div style="margin-top: 4px;">
                            <span style="color: #22c55e;">â– </span> Green bars = positive correlation (tend to happen together)
                            <span style="margin-left: 15px; color: #ef4444;">â– </span> Red bars = negative correlation (tend not to happen together)
                        </div>
                    </div>
                    <div class="chart-container" id="correlationChartContainer" style="min-height: 350px;">
                        <canvas id="recordCorrelationChart"></canvas>
                    </div>
                </div>
            </div>

            <div id="recordPlaceholder" style="text-align: center; padding: 60px 20px; color: var(--text-secondary);">
                <h2 style="font-size: 48px; margin-bottom: 20px;">ðŸ”</h2>
                <h3 style="margin-bottom: 10px;">Select a Record to Begin</h3>
                <p>Choose an activity, weather, social interaction, or factor from the dropdown above to analyze its relationships and patterns.</p>
            </div>
        </div>

        <div id="settingsTab" class="tab-content">
            <div class="settings-container">
                <!-- Account Section -->
                <div class="settings-section">
                    <h2 class="settings-title">ðŸ‘¤ Account</h2>
                    <div id="accountInfo"></div>
                </div>

                <!-- Data Export Section -->
                <div class="settings-section">
                    <h2 class="settings-title">ðŸ“Š Data Export</h2>
                    <div style="padding: 20px; background: var(--bg-secondary); border-radius: 12px;">
                        <p style="margin-bottom: 15px; color: var(--text-secondary);">Export your mood tracking data to Excel format for further analysis or backup.</p>
                        <button class="export-btn" id="exportDataBtn" style="width: 100%; padding: 12px; font-size: 16px;">ðŸ“Š Export Data to Excel</button>
                    </div>
                </div>

                <!-- Data Import Section -->
                <div class="settings-section">
                    <h2 class="settings-title">ðŸ“¥ Data Import</h2>
                    <div style="padding: 20px; background: var(--bg-secondary); border-radius: 12px;">
                        <p style="margin-bottom: 15px; color: var(--text-secondary);">Import mood tracking data from a previously exported Excel or CSV file. This will merge with your existing data.</p>
                        <div style="margin-bottom: 15px; padding: 12px; background: #FFF5E6; border-radius: 8px; border-left: 4px solid var(--accent);">
                            <strong style="color: var(--accent);">ðŸ“Œ Note:</strong> 
                            <span style="color: var(--text-primary);">Importing data will overwrite any existing entries for the same dates. Make sure to export your current data first if needed.</span>
                        </div>
                        <input type="file" id="importDataInput" accept=".xlsx,.xls,.csv" style="display: none;">
                        <button class="export-btn" id="importDataBtn" style="width: 100%; padding: 12px; font-size: 16px; background: var(--accent); color: white; border: none;">ðŸ“¥ Import Data from File</button>
                        <div id="importStatus" style="margin-top: 10px; text-align: center; display: none;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                                <span class="sync-icon">â³</span>
                                <span id="importStatusText">Processing...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Customization Section -->
                <div class="settings-section">
                    <h2 class="settings-title">ðŸŽ¨ Customize Your Tracking</h2>
                    <div id="customizationContent"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mood Entry Modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-date" id="modalDate">January 15, 2024</div>
                <div class="modal-subtitle">How was your day?</div>
            </div>

            <div class="mood-section">
                <h3 class="section-title">Your Mood</h3>
                <div class="mood-options">
                    <div class="mood-option" data-mood="5">
                        <div class="mood-emoji">ðŸ˜„</div>
                        <div class="mood-label">Great</div>
                    </div>
                    <div class="mood-option" data-mood="4">
                        <div class="mood-emoji">ðŸ™‚</div>
                        <div class="mood-label">Good</div>
                    </div>
                    <div class="mood-option" data-mood="3">
                        <div class="mood-emoji">ðŸ˜</div>
                        <div class="mood-label">Okay</div>
                    </div>
                    <div class="mood-option" data-mood="2">
                        <div class="mood-emoji">ðŸ˜•</div>
                        <div class="mood-label">Meh</div>
                    </div>
                    <div class="mood-option" data-mood="1">
                        <div class="mood-emoji">ðŸ˜¢</div>
                        <div class="mood-label">Rough</div>
                    </div>
                </div>
            </div>

            <div id="dynamicSocialSection"></div>
            <div id="dynamicWeatherSection"></div>
            <div id="dynamicActivitySection"></div>
            <div id="dynamicFactorSection"></div>
            <div id="dynamicSleepTimeSection"></div>
            <div id="dynamicSleepSection"></div>

            <div class="note-section">
                <h3 class="section-title">Notes (Optional)</h3>
                <textarea class="note-input" id="noteInput" placeholder="What made today special?"></textarea>
            </div>

            <div class="modal-actions">
                <button class="btn btn-cancel" id="cancelBtn">Cancel</button>
                <button class="btn btn-save" id="saveBtn">Save</button>
            </div>
        </div>
    </div>

    <!-- Emoji Picker Modal -->
    <div class="emoji-modal" id="emojiModal">
        <div class="emoji-modal-content">
            <div class="emoji-modal-header">
                <div class="emoji-modal-title">Choose an Emoji</div>
                <button class="emoji-modal-close" id="emojiModalClose">Ã—</button>
            </div>
            <div class="emoji-grid-container" id="emojiGridContainer"></div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, signInWithPopup, GoogleAuthProvider, signInAnonymously, linkWithCredential, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, doc, setDoc, getDoc, getDocs, collection, query, where, writeBatch } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import firebaseConfig from './firebase-config.js';

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // ============================================
        // DEMO MODE CONFIGURATION
        // ============================================
        const OWNER_UIDS = [
            'zQk7rKb2IacJZcCRUc3fPdEPGL93',
            'FhF899SAuoheoeJO9v8SXwhcFw73',
            'CSz6ynVSedVP9rJPRuFhJ3XqQBj2'
        ];
        const isOwner = (uid) => OWNER_UIDS.includes(uid);
        let isDemoMode = true; // Default to demo mode, only owner can use real mode
        let demoMoodData = {}; // In-memory storage for demo mode
        let demoSettings = null; // In-memory settings for demo mode

        // Generate realistic sample data for demo
        function generateDemoData() {
            const data = {};
            const today = new Date();
            const activities = ['gym', 'movies', 'series', 'cooking', 'walking', 'reading', 'learning', 'singing'];
            const factors = ['coffee', 'tea', 'snack', 'alcohol', 'beverage'];
            const social = ['friends', 'family', 'partner', 'alone'];
            const weather = ['sunny', 'cloudy', 'rainy'];
            const sleepQuality = ['poor', 'ok', 'good', 'great'];
            
            // Generate 90 days of data
            for (let i = 0; i < 90; i++) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                const dateKey = date.toISOString().split('T')[0];
                
                // Skip some random days (15% chance of no entry)
                if (Math.random() < 0.15) continue;
                
                // Generate mood with some patterns
                let mood;
                const dayOfWeek = date.getDay();
                const random = Math.random();
                
                // Weekends tend to be happier
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    mood = random < 0.3 ? 4 : random < 0.7 ? 5 : 3;
                } else {
                    // Weekdays more varied
                    if (random < 0.1) mood = 1;
                    else if (random < 0.25) mood = 2;
                    else if (random < 0.45) mood = 3;
                    else if (random < 0.75) mood = 4;
                    else mood = 5;
                }
                
                // Generate sleep data
                const sleepHour = 22 + Math.floor(Math.random() * 3); // 10 PM - 12 AM
                const sleepMin = Math.floor(Math.random() * 60);
                const wakeHour = 6 + Math.floor(Math.random() * 3); // 6 AM - 8 AM
                const wakeMin = Math.floor(Math.random() * 60);
                const sleepDuration = ((wakeHour + 24 - sleepHour) % 24) * 60 + (wakeMin - sleepMin);
                
                // Correlate sleep quality with mood somewhat
                let sleep;
                if (mood >= 4) {
                    sleep = Math.random() < 0.7 ? (Math.random() < 0.5 ? 'great' : 'good') : 'ok';
                } else if (mood <= 2) {
                    sleep = Math.random() < 0.6 ? (Math.random() < 0.5 ? 'poor' : 'ok') : 'good';
                } else {
                    sleep = sleepQuality[Math.floor(Math.random() * sleepQuality.length)];
                }
                
                // Random activities (1-3)
                const numActivities = 1 + Math.floor(Math.random() * 3);
                const selectedActivities = [];
                const shuffledAct = [...activities].sort(() => Math.random() - 0.5);
                for (let j = 0; j < numActivities; j++) {
                    selectedActivities.push(shuffledAct[j]);
                }
                
                // Gym correlates with good mood
                if (mood >= 4 && Math.random() < 0.4 && !selectedActivities.includes('gym')) {
                    selectedActivities.push('gym');
                }
                
                // Random factors (0-2)
                const numFactors = Math.floor(Math.random() * 3);
                const selectedFactors = [];
                const shuffledFac = [...factors].sort(() => Math.random() - 0.5);
                for (let j = 0; j < numFactors; j++) {
                    selectedFactors.push(shuffledFac[j]);
                }
                
                // Random social (1-2)
                const numSocial = 1 + Math.floor(Math.random() * 2);
                const selectedSocial = [];
                const shuffledSoc = [...social].sort(() => Math.random() - 0.5);
                for (let j = 0; j < numSocial; j++) {
                    selectedSocial.push(shuffledSoc[j]);
                }
                
                // Weather based on "season" (rough approximation)
                const month = date.getMonth();
                let selectedWeather;
                if (month >= 5 && month <= 8) {
                    selectedWeather = Math.random() < 0.7 ? 'sunny' : 'cloudy';
                } else if (month >= 11 || month <= 2) {
                    selectedWeather = Math.random() < 0.3 ? 'sunny' : (Math.random() < 0.5 ? 'cloudy' : 'rainy');
                } else {
                    selectedWeather = weather[Math.floor(Math.random() * weather.length)];
                }
                
                data[dateKey] = {
                    mood: mood,
                    activities: selectedActivities,
                    factors: selectedFactors,
                    social: selectedSocial,
                    weather: [selectedWeather],
                    sleep: sleep,
                    sleepTime: `${sleepHour.toString().padStart(2, '0')}:${sleepMin.toString().padStart(2, '0')}`,
                    wakeTime: `${wakeHour.toString().padStart(2, '0')}:${wakeMin.toString().padStart(2, '0')}`,
                    sleepDuration: sleepDuration,
                    note: ''
                };
            }
            
            return data;
        }

        // Initialize demo data
        demoMoodData = generateDemoData();
        // ============================================

        // Global state
        let currentUser = null;
        let currentDate = new Date();
        let selectedDate = null;
        let charts = {};
        const moodEmojis = { 1: 'ðŸ˜¢', 2: 'ðŸ˜•', 3: 'ðŸ˜', 4: 'ðŸ™‚', 5: 'ðŸ˜„' };
        const moodColors = { 1: '#7B8CDE', 2: '#A8D5E5', 3: '#F5E6A3', 4: '#FFCB8E', 5: '#FFE066' };

        // Default customization options
        const defaultOptions = {
            people: {
                enabled: true,
                emoji: 'ðŸ‘¥',
                options: [
                    { id: 'friends', emoji: 'ðŸ‘¯', label: 'Friends', default: true },
                    { id: 'family', emoji: 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§', label: 'Family', default: true },
                    { id: 'partner', emoji: 'ðŸ’•', label: 'Partner', default: true },
                    { id: 'alone', emoji: 'ðŸ§˜', label: 'Solo', default: true },
                    { id: 'facetime', emoji: 'ðŸ“±', label: 'FaceTime', default: false },
                    { id: 'calling', emoji: 'ðŸ“ž', label: 'Calling', default: false }
                ]
            },
            activities: {
                enabled: true,
                emoji: 'ðŸŽ¯',
                options: [
                    { id: 'gym', emoji: 'ðŸ‹ï¸', label: 'Gym', default: true },
                    { id: 'movies', emoji: 'ðŸŽ¬', label: 'Movies', default: true },
                    { id: 'series', emoji: 'ðŸ“º', label: 'Series', default: true },
                    { id: 'cooking', emoji: 'ðŸ³', label: 'Cooking', default: true },
                    { id: 'singing', emoji: 'ðŸŽ¤', label: 'Singing', default: true },
                    { id: 'walking', emoji: 'ðŸš¶', label: 'Walking', default: true },
                    { id: 'learning', emoji: 'ðŸ“š', label: 'Learning', default: true },
                    { id: 'reading', emoji: 'ðŸ“–', label: 'Reading', default: true },
                    { id: 'jogging', emoji: 'ðŸƒ', label: 'Jogging', default: false },
                    { id: 'yoga', emoji: 'ðŸ§˜â€â™€ï¸', label: 'Yoga', default: false },
                    { id: 'dancing', emoji: 'ðŸ’ƒ', label: 'Dancing', default: false },
                    { id: 'teamsports', emoji: 'âš½', label: 'Team Sports', default: false },
                    { id: 'writing', emoji: 'âœï¸', label: 'Writing', default: false },
                    { id: 'volunteering', emoji: 'ðŸ¤', label: 'Volunteering', default: false },
                    { id: 'therapist', emoji: 'ðŸ’­', label: 'Therapist', default: false },
                    { id: 'painting', emoji: 'ðŸŽ¨', label: 'Painting', default: false },
                    { id: 'crafting', emoji: 'âœ‚ï¸', label: 'Crafting', default: false },
                    { id: 'instrument', emoji: 'ðŸŽ¸', label: 'Instrument', default: false },
                    { id: 'baking', emoji: 'ðŸ§', label: 'Baking', default: false },
                    { id: 'meditation', emoji: 'ðŸ•‰ï¸', label: 'Meditation', default: false },
                    { id: 'gaming', emoji: 'ðŸŽ®', label: 'Gaming', default: false }
                ]
            },
            factors: {
                enabled: true,
                emoji: 'ðŸƒ',
                options: [
                    { id: 'snack', emoji: 'ðŸ¿', label: 'Snack', default: true },
                    { id: 'coffee', emoji: 'â˜•', label: 'Coffee', default: true },
                    { id: 'tea', emoji: 'ðŸµ', label: 'Tea', default: true },
                    { id: 'alcohol', emoji: 'ðŸº', label: 'Alcohol', default: true },
                    { id: 'smoking', emoji: 'ðŸš¬', label: 'Smoking', default: true },
                    { id: 'tobacco', emoji: 'ðŸŒ¿', label: 'Tobacco', default: true },
                    { id: 'beverage', emoji: 'ðŸ¥¤', label: 'Beverage', default: true },
                    { id: 'intercourse', emoji: 'ðŸ’‘', label: 'Intercourse', default: true }
                ]
            },
            weather: {
                enabled: true,
                emoji: 'ðŸŒ¤ï¸',
                options: [
                    { id: 'sunny', emoji: 'â˜€ï¸', label: 'Sunny', default: true },
                    { id: 'cloudy', emoji: 'â˜ï¸', label: 'Cloudy', default: true },
                    { id: 'rainy', emoji: 'ðŸŒ§ï¸', label: 'Rainy', default: true },
                    { id: 'snowy', emoji: 'â„ï¸', label: 'Snowy', default: true }
                ]
            },
            sleep: {
                enabled: true,
                emoji: 'ðŸ˜´',
                options: [
                    { id: 'poor', emoji: 'ðŸ˜´', label: 'Poor', default: true },
                    { id: 'ok', emoji: 'ðŸ˜ª', label: 'Okay', default: true },
                    { id: 'good', emoji: 'ðŸ˜Œ', label: 'Good', default: true },
                    { id: 'great', emoji: 'ðŸŒŸ', label: 'Great', default: true }
                ]
            }
        };

        // User customization settings
        let userSettings = JSON.parse(JSON.stringify(defaultOptions)); // Deep clone

        // DOM Elements
        const authSection = document.getElementById('authSection');
        const authModal = document.getElementById('authModal');
        const googleSignInBtn = document.getElementById('googleSignInBtn');
        const skipAuthBtn = document.getElementById('skipAuthBtn');
        const calendar = document.getElementById('calendar');
        const monthTitle = document.getElementById('monthTitle');
        const prevMonthBtn = document.getElementById('prevMonth');
        const nextMonthBtn = document.getElementById('nextMonth');
        const modalOverlay = document.getElementById('modalOverlay');
        const modalDate = document.getElementById('modalDate');
        const cancelBtn = document.getElementById('cancelBtn');
        const saveBtn = document.getElementById('saveBtn');
        const noteInput = document.getElementById('noteInput');
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        const applyDateRangeBtn = document.getElementById('applyDateRange');
        const toast = document.getElementById('toast');

        // Toast notification function
        function showToast(message, isError = false) {
            toast.textContent = message;
            toast.className = 'toast show' + (isError ? ' error' : '');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Initialize date range inputs - will be updated after loading user data
        const today = new Date();
        endDateInput.value = today.toISOString().split('T')[0];
        
        // Temporary default (will be replaced with actual first record date)
        const threeMonthsAgo = new Date(today.getFullYear(), today.getMonth() - 3, 1);
        startDateInput.value = threeMonthsAgo.toISOString().split('T')[0];

        // Function to set start date to first record
        async function setStartDateToFirstRecord() {
            try {
                const allDates = await getAllMoodData('2020-01-01', today.toISOString().split('T')[0]);
                if (allDates.length > 0) {
                    // Sort by date to find first record
                    allDates.sort((a, b) => new Date(a.date) - new Date(b.date));
                    startDateInput.value = allDates[0].date;
                }
            } catch (error) {
                console.log('Using default start date');
            }
        }

        // Authentication Functions
        async function initAuth() {
            // Check if trying to login as owner
            const urlParams = new URLSearchParams(window.location.search);
            const ownerLogin = urlParams.get('owner');
            
            if (ownerLogin === 'true') {
                // Owner wants to login - show Firebase auth
                onAuthStateChanged(auth, async (user) => {
                    if (user && isOwner(user.uid)) {
                        // Owner logged in successfully
                        isDemoMode = false;
                        currentUser = user;
                        hideDemoBanner();
                        await handleUserSignedIn(user);
                    } else if (user && !isOwner(user.uid)) {
                        // Someone else tried to login - sign them out and go to demo
                        await signOut(auth);
                        showToast('âš ï¸ Access restricted to owner only', true);
                        startDemoMode();
                    } else {
                        // Not logged in - show Google sign in for owner
                        showOwnerLoginModal();
                    }
                });
            } else {
                // Normal access - always demo mode
                startDemoMode();
            }
        }

        function startDemoMode() {
            isDemoMode = true;
            currentUser = { uid: 'demo_user', isAnonymous: true, displayName: 'Demo User' };
            
            // Show demo banner
            showDemoBanner();
            
            // Hide auth modal if showing
            hideAuthModal();
            
            // Update UI for demo mode
            updateAuthUIForDemo();
            
            // Load demo data
            userSettings = JSON.parse(JSON.stringify(defaultOptions));
            loadMoodData(currentDate.getFullYear(), currentDate.getMonth());
            setStartDateToFirstRecord();
            setDefaultSleepDates();
            setDefaultRecordDates();
            renderAccountInfo();
            renderCustomization();
        }

        function showDemoBanner() {
            const banner = document.getElementById('demoBanner');
            if (banner) {
                banner.style.display = 'flex';
                document.body.classList.add('demo-mode');
            }
        }

        function hideDemoBanner() {
            const banner = document.getElementById('demoBanner');
            if (banner) {
                banner.style.display = 'none';
                document.body.classList.remove('demo-mode');
            }
        }

        function updateAuthUIForDemo() {
            authSection.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px; background: var(--card-bg); padding: 8px 16px; border-radius: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.08);">
                    <span style="font-size: 1.2rem;">ðŸŽ®</span>
                    <span style="font-weight: 600; color: var(--text-primary);">Demo Mode</span>
                </div>
            `;
        }

        function showOwnerLoginModal() {
            authModal.classList.add('show');
            // Update modal content for owner login
            const authContent = authModal.querySelector('.auth-content');
            if (authContent) {
                authContent.innerHTML = `
                    <div class="auth-title">ðŸ” Owner Login</div>
                    <div class="auth-description">
                        Sign in with your Google account to access your personal data.
                    </div>
                    <button class="google-sign-in-btn" id="ownerGoogleSignInBtn">
                        <svg class="google-icon" viewBox="0 0 24 24">
                            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                        </svg>
                        Sign in with Google
                    </button>
                    <button class="skip-btn" onclick="window.location.href = window.location.pathname;">â† Back to Demo</button>
                `;
                
                document.getElementById('ownerGoogleSignInBtn').addEventListener('click', async () => {
                    try {
                        const provider = new GoogleAuthProvider();
                        await signInWithPopup(auth, provider);
                    } catch (error) {
                        console.error('Sign-in error:', error);
                        if (error.code !== 'auth/popup-closed-by-user' && error.code !== 'auth/cancelled-popup-request') {
                            showToast(`âŒ Sign-in failed: ${error.message}`, true);
                        }
                    }
                });
            }
        }

        // Owner login button in demo banner
        document.getElementById('ownerLoginBtn')?.addEventListener('click', () => {
            window.location.href = window.location.pathname + '?owner=true';
        });

        function showAuthModal() {
            authModal.classList.add('show');
        }

        function hideAuthModal() {
            authModal.classList.remove('show');
            localStorage.setItem('hasSeenAuth', 'true');
        }

        async function handleUserSignedIn(user) {
            // Only allow owner to use real Firebase data
            if (!isOwner(user.uid)) {
                // Not the owner - force demo mode
                await signOut(auth);
                startDemoMode();
                return;
            }
            
            // Owner logged in
            isDemoMode = false;
            hideAuthModal();
            hideDemoBanner();
            updateAuthUI(user);
            
            // Load user settings from Firebase
            await loadUserSettings();
            
            // Load mood data - wait for it to complete
            await loadMoodData(currentDate.getFullYear(), currentDate.getMonth());
            
            // Set start date to first record
            await setStartDateToFirstRecord();
            await setDefaultSleepDates();
            await setDefaultRecordDates();
            
            // Update settings page if on that tab
            renderAccountInfo();
            renderCustomization();
            
            showToast('âœ… Welcome back, Owner!');
        }

        function updateAuthUI(user) {
            // In demo mode, show demo UI
            if (isDemoMode) {
                updateAuthUIForDemo();
                return;
            }
            
            // Owner logged in - show full UI
            const displayName = user.displayName || 'Owner';
            const photoURL = user.photoURL || 'https://via.placeholder.com/36';
            const email = user.email ? user.email.split('@')[0] : 'owner';
            authSection.innerHTML = `
                <div class="user-info">
                    <img src="${photoURL}" alt="${displayName}" class="user-avatar">
                    <div>
                        <div class="user-name">${displayName || email}</div>
                        <div class="sync-status" id="syncStatus">âœ“ Synced (Owner)</div>
                    </div>
                    <button class="sign-out-btn" id="signOutBtn">Sign Out</button>
                </div>
            `;
            document.getElementById('signOutBtn').addEventListener('click', handleSignOut);
        }

        function updateSyncStatus(message, isLoading = false) {
            const syncStatus = document.getElementById('syncStatus');
            if (syncStatus) {
                syncStatus.innerHTML = isLoading ? 
                    `<span class="sync-icon">âŸ³</span> ${message}` : 
                    `âœ“ ${message}`;
            }
        }

        async function upgradeAccount() {
            // In demo mode, this just shows a message
            if (isDemoMode) {
                showToast('ðŸŽ® This is demo mode. Data is temporary.', false);
                return;
            }
            // Otherwise redirect to owner login
            window.location.href = window.location.pathname + '?owner=true';
        }

        async function mergeAnonymousData(newUser) {
            try {
                showToast('ðŸ”„ Merging your data...');
                
                // Get all data from localStorage (anonymous session data)
                const localData = {};
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('mood_')) {
                        const dateKey = key.replace('mood_', '');
                        localData[dateKey] = JSON.parse(localStorage.getItem(key));
                    }
                }

                // Upload to Firestore under new user ID
                if (Object.keys(localData).length > 0) {
                    const batch = writeBatch(db);
                    for (const [dateKey, moodData] of Object.entries(localData)) {
                        const docRef = doc(db, 'users', newUser.uid, 'moods', dateKey);
                        batch.set(docRef, moodData, { merge: true });
                    }
                    await batch.commit();
                    console.log('Successfully merged', Object.keys(localData).length, 'mood entries');
                    showToast('âœ… Data merged successfully!');
                } else {
                    console.log('No local data to merge');
                }
            } catch (error) {
                console.error('Error merging data:', error);
                showToast('âš ï¸ Some data may not have synced', true);
            }
        }

        async function migrateLocalData() {
            try {
                // Get all local data
                const localData = {};
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('mood_')) {
                        const dateKey = key.replace('mood_', '');
                        localData[dateKey] = JSON.parse(localStorage.getItem(key));
                    }
                }

                // Upload to Firestore
                const batch = writeBatch(db);
                for (const [dateKey, moodData] of Object.entries(localData)) {
                    const docRef = doc(db, 'users', currentUser.uid, 'moods', dateKey);
                    batch.set(docRef, moodData, { merge: true });
                }
                await batch.commit();
                
                console.log('Data migration completed successfully');
            } catch (error) {
                console.error('Error migrating data:', error);
            }
        }

        googleSignInBtn.addEventListener('click', async () => {
            // Redirect to owner login flow
            window.location.href = window.location.pathname + '?owner=true';
        });

        skipAuthBtn.addEventListener('click', async () => {
            // Start demo mode
            startDemoMode();
        });

        async function handleSignOut() {
            try {
                await signOut(auth);
                // Go back to demo mode
                window.location.href = window.location.pathname;
            } catch (error) {
                console.error('Error signing out:', error);
            }
        }

        // Settings Functions
        async function loadUserSettings() {
            if (!currentUser) return;

            // Demo mode - use default settings
            if (isDemoMode) {
                userSettings = JSON.parse(JSON.stringify(defaultOptions));
                console.log('Demo mode: Using default settings');
                return;
            }

            // Owner mode - load from Firebase
            try {
                const docRef = doc(db, 'users', currentUser.uid, 'settings', 'customization');
                const docSnap = await getDoc(docRef);
                
                if (docSnap.exists()) {
                    const savedSettings = docSnap.data();
                    // The data is saved as the settings object itself, not wrapped in 'options'
                    userSettings = savedSettings || JSON.parse(JSON.stringify(defaultOptions));
                    console.log('Settings loaded from Firestore:', userSettings);
                } else {
                    // Use defaults
                    userSettings = JSON.parse(JSON.stringify(defaultOptions));
                    console.log('Using default settings');
                }
            } catch (error) {
                console.error('Error loading settings:', error);
                userSettings = JSON.parse(JSON.stringify(defaultOptions));
            }
        }

        async function saveUserSettings() {
            // Demo mode - don't save
            if (isDemoMode) {
                showToast('ðŸŽ® Demo mode - changes are temporary', false);
                return;
            }

            if (!currentUser) {
                showToast('âš ï¸ Sign in to save custom settings', true);
                return;
            }

            try {
                const docRef = doc(db, 'users', currentUser.uid, 'settings', 'customization');
                // Save the entire userSettings object
                await setDoc(docRef, userSettings, { merge: false });
                showToast('âœ… Settings saved successfully!');
                console.log('Settings saved:', userSettings);
            } catch (error) {
                console.error('Error saving settings:', error);
                console.error('Error details:', error.message, error.code);
                showToast('âŒ Failed to save settings: ' + error.message, true);
            }
        }

        // Auto-save with debouncing to avoid too many writes
        let autoSaveTimeout = null;
        async function autoSaveSettings() {
            // Demo mode - don't auto-save to Firebase
            if (isDemoMode) {
                return;
            }
            
            if (!currentUser) {
                return;
            }

            // Clear previous timeout
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }

            // Set new timeout - save after 1 second of no changes
            autoSaveTimeout = setTimeout(async () => {
                try {
                    const docRef = doc(db, 'users', currentUser.uid, 'settings', 'customization');
                    await setDoc(docRef, userSettings, { merge: false });
                    console.log('Settings auto-saved');
                    // Don't show toast for auto-save to avoid spam
                } catch (error) {
                    console.error('Auto-save error:', error);
                }
            }, 1000);
        }

        function renderAccountInfo() {
            const accountInfo = document.getElementById('accountInfo');
            
            // Demo mode - show demo account info
            if (isDemoMode) {
                accountInfo.innerHTML = `
                    <div class="settings-info" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px;">
                        <div style="font-size: 2.5rem; margin-bottom: 10px;">ðŸŽ®</div>
                        <div class="settings-user-details">
                            <div class="settings-user-name" style="color: white;">Demo Mode</div>
                            <div class="settings-user-email" style="color: rgba(255,255,255,0.8);">Explore all features freely!</div>
                            <span class="settings-user-status" style="background: rgba(255,255,255,0.2); color: white;">Data is temporary</span>
                        </div>
                    </div>
                    <p style="margin-top: 16px; color: var(--text-secondary); text-align: center; font-size: 0.9rem;">
                        All your changes will be reset when you refresh the page.
                    </p>
                `;
                return;
            }
            
            // Owner mode - show real account info
            if (currentUser) {
                const displayName = currentUser.displayName || 'Owner';
                const email = currentUser.email || 'No email';
                const photoURL = currentUser.photoURL || 'https://via.placeholder.com/60';
                
                accountInfo.innerHTML = `
                    <div class="settings-info">
                        <img src="${photoURL}" alt="${displayName}" class="settings-avatar">
                        <div class="settings-user-details">
                            <div class="settings-user-name">${displayName}</div>
                            <div class="settings-user-email">${email}</div>
                            <span class="settings-user-status">Owner Account âœ“</span>
                        </div>
                    </div>
                    <button class="btn btn-cancel" id="settingsSignOutBtn" style="width: 100%; padding: 14px;">
                        Sign Out
                    </button>
                `;
                document.getElementById('settingsSignOutBtn').addEventListener('click', handleSignOut);
            }
        }

        function renderCustomization() {
            const customizationContent = document.getElementById('customizationContent');
            
            // Demo mode - allow customization but with notice
            let demoNotice = '';
            if (isDemoMode) {
                demoNotice = `
                    <div style="padding: 16px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; margin-bottom: 24px; color: white;">
                        <strong>ðŸŽ® Demo Mode:</strong> 
                        <span>Feel free to customize! Changes won't be saved permanently.</span>
                    </div>
                `;
            }

            let html = demoNotice + `
                <div style="padding: 16px; background: #FFF5E6; border-radius: 12px; margin-bottom: 24px; border-left: 4px solid var(--accent);">
                    <strong style="color: var(--accent);">ðŸ“Œ Note:</strong> 
                    <span style="color: var(--text-primary);">Deselecting options only affects future entries. Your existing mood data will remain unchanged and safe.</span>
                </div>
                <p style="color: var(--text-secondary); margin-bottom: 24px;">Customize what appears in your daily mood entries. Toggle categories on/off, select default options, and create your own custom options!</p>
            `;

            const categoryNames = {
                people: 'People',
                activities: 'Activities',
                factors: 'Factors',
                weather: 'Weather',
                sleep: 'Sleep Quality'
            };

            for (const [categoryKey, categoryName] of Object.entries(categoryNames)) {
                const category = userSettings[categoryKey];
                
                html += `
                    <div class="category-section" data-category="${categoryKey}">
                        <div class="category-toggle" data-category-key="${categoryKey}">
                            <div class="category-toggle-left">
                                <span class="category-toggle-emoji">${category.emoji}</span>
                                <span class="category-toggle-label">${categoryName}</span>
                            </div>
                            <div class="toggle-switch ${category.enabled ? 'active' : ''}" id="toggle-${categoryKey}"></div>
                        </div>
                        
                        <div class="category-options" id="options-${categoryKey}" style="display: ${category.enabled ? 'block' : 'none'}">
                            <div class="options-grid" id="grid-${categoryKey}">
                `;
                
                // Render options
                category.options.forEach(option => {
                    const isSelected = option.enabled !== false;
                    const isDefault = option.default;
                    html += `
                        <div class="custom-option ${isSelected ? 'selected' : ''} ${isDefault ? 'default' : ''}" 
                             data-category-key="${categoryKey}" data-option-id="${option.id}">
                            <button class="edit-btn" data-category-key="${categoryKey}" data-option-id="${option.id}" title="Edit">âœï¸</button>
                            ${!isDefault ? '<button class="remove-btn" data-category-key="' + categoryKey + '" data-option-id="' + option.id + '" title="Delete">Ã—</button>' : ''}
                            <div class="detail-emoji">${option.emoji}</div>
                            <div class="detail-label">${option.label}</div>
                        </div>
                    `;
                });
                
                // Add option button
                html += `
                                <button class="add-option-btn" data-category-key="${categoryKey}">
                                    <div class="add-option-icon">+</div>
                                    <div>Add Custom</div>
                                </button>
                            </div>
                            
                            <div class="custom-option-form" id="form-${categoryKey}">
                                <div class="form-group">
                                    <label class="form-label">Name</label>
                                    <input type="text" class="form-input" id="input-name-${categoryKey}" placeholder="e.g., Swimming">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Emoji</label>
                                    <button type="button" class="form-input" id="emoji-display-${categoryKey}" data-category-key="${categoryKey}" style="cursor: pointer; text-align: left; font-size: 1.5rem; display: flex; align-items: center; gap: 8px;">
                                        <span id="emoji-preview-${categoryKey}">ðŸ˜€</span>
                                        <span style="font-size: 0.9rem; color: var(--text-secondary);">Click to change</span>
                                    </button>
                                </div>
                                <div class="form-actions">
                                    <button class="form-btn cancel" data-category-key="${categoryKey}" data-action="cancel">Cancel</button>
                                    <button class="form-btn save" data-category-key="${categoryKey}" data-action="save">Add</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Note: No manual save button needed - auto-saves on every change
            
            customizationContent.innerHTML = html;

            // Attach event listeners
            attachCustomizationListeners();
        }

        function attachCustomizationListeners() {
            // Category toggles
            document.querySelectorAll('.category-toggle').forEach(toggle => {
                toggle.addEventListener('click', function() {
                    const categoryKey = this.dataset.categoryKey;
                    toggleCategory(categoryKey);
                });
            });

            // Option toggles
            document.querySelectorAll('.custom-option').forEach(option => {
                option.addEventListener('click', function(e) {
                    // Don't toggle if clicking remove or edit button
                    if (e.target.classList.contains('remove-btn') || e.target.classList.contains('edit-btn')) return;
                    const categoryKey = this.dataset.categoryKey;
                    const optionId = this.dataset.optionId;
                    toggleOption(categoryKey, optionId);
                });
            });

            // Edit buttons
            document.querySelectorAll('.edit-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const categoryKey = this.dataset.categoryKey;
                    const optionId = this.dataset.optionId;
                    editOption(categoryKey, optionId);
                });
            });

            // Remove buttons
            document.querySelectorAll('.remove-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const categoryKey = this.dataset.categoryKey;
                    const optionId = this.dataset.optionId;
                    removeOption(categoryKey, optionId);
                });
            });

            // Add option buttons
            document.querySelectorAll('.add-option-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const categoryKey = this.dataset.categoryKey;
                    showAddOptionForm(categoryKey);
                });
            });

            // Form buttons
            document.querySelectorAll('.form-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const categoryKey = this.dataset.categoryKey;
                    const action = this.dataset.action;
                    if (action === 'cancel') {
                        hideAddOptionForm(categoryKey);
                    } else if (action === 'save') {
                        addCustomOption(categoryKey);
                    }
                });
            });

            // Emoji display buttons
            document.querySelectorAll('[id^="emoji-display-"]').forEach(btn => {
                btn.addEventListener('click', function() {
                    const categoryKey = this.dataset.categoryKey;
                    openEmojiModal(categoryKey);
                });
            });

            // Note: Auto-save is enabled for all changes - no manual save button needed
        }

        // Comprehensive emoji list organized by category
        const allEmojis = {
            'Smileys & Emotion': ['ðŸ˜€','ðŸ˜ƒ','ðŸ˜„','ðŸ˜','ðŸ˜†','ðŸ˜…','ðŸ¤£','ðŸ˜‚','ðŸ™‚','ðŸ™ƒ','ðŸ˜‰','ðŸ˜Š','ðŸ˜‡','ðŸ¥°','ðŸ˜','ðŸ¤©','ðŸ˜˜','ðŸ˜—','â˜ºï¸','ðŸ˜š','ðŸ˜™','ðŸ¥²','ðŸ˜‹','ðŸ˜›','ðŸ˜œ','ðŸ¤ª','ðŸ˜','ðŸ¤‘','ðŸ¤—','ðŸ¤­','ðŸ¤«','ðŸ¤”','ðŸ¤','ðŸ¤¨','ðŸ˜','ðŸ˜‘','ðŸ˜¶','ðŸ˜','ðŸ˜’','ðŸ™„','ðŸ˜¬','ðŸ¤¥','ðŸ˜Œ','ðŸ˜”','ðŸ˜ª','ðŸ¤¤','ðŸ˜´','ðŸ˜·','ðŸ¤’','ðŸ¤•','ðŸ¤¢','ðŸ¤®','ðŸ¤§','ðŸ¥µ','ðŸ¥¶','ðŸ¥´','ðŸ˜µ','ðŸ¤¯','ðŸ¤ ','ðŸ¥³','ðŸ¥¸','ðŸ˜Ž','ðŸ¤“','ðŸ§','ðŸ˜•','ðŸ˜Ÿ','ðŸ™','â˜¹ï¸','ðŸ˜®','ðŸ˜¯','ðŸ˜²','ðŸ˜³','ðŸ¥º','ðŸ˜¦','ðŸ˜§','ðŸ˜¨','ðŸ˜°','ðŸ˜¥','ðŸ˜¢','ðŸ˜­','ðŸ˜±','ðŸ˜–','ðŸ˜£','ðŸ˜ž','ðŸ˜“','ðŸ˜©','ðŸ˜«','ðŸ¥±','ðŸ˜¤','ðŸ˜¡','ðŸ˜ ','ðŸ¤¬','ðŸ˜ˆ','ðŸ‘¿','ðŸ’€','â˜ ï¸','ðŸ’©','ðŸ¤¡','ðŸ‘¹','ðŸ‘º','ðŸ‘»','ðŸ‘½','ðŸ‘¾','ðŸ¤–','ðŸ˜º','ðŸ˜¸','ðŸ˜¹','ðŸ˜»','ðŸ˜¼','ðŸ˜½','ðŸ™€','ðŸ˜¿','ðŸ˜¾'],
            'People & Body': ['ðŸ‘‹','ðŸ¤š','ðŸ–ï¸','âœ‹','ðŸ––','ðŸ‘Œ','ðŸ¤Œ','ðŸ¤','âœŒï¸','ðŸ¤ž','ðŸ¤Ÿ','ðŸ¤˜','ðŸ¤™','ðŸ‘ˆ','ðŸ‘‰','ðŸ‘†','ðŸ–•','ðŸ‘‡','â˜ï¸','ðŸ‘','ðŸ‘Ž','âœŠ','ðŸ‘Š','ðŸ¤›','ðŸ¤œ','ðŸ‘','ðŸ™Œ','ðŸ‘','ðŸ¤²','ðŸ¤','ðŸ™','âœï¸','ðŸ’…','ðŸ¤³','ðŸ’ª','ðŸ¦¾','ðŸ¦¿','ðŸ¦µ','ðŸ¦¶','ðŸ‘‚','ðŸ¦»','ðŸ‘ƒ','ðŸ§ ','ðŸ«€','ðŸ«','ðŸ¦·','ðŸ¦´','ðŸ‘€','ðŸ‘ï¸','ðŸ‘…','ðŸ‘„','ðŸ’‹','ðŸ©¸'],
            'Animals & Nature': ['ðŸ¶','ðŸ±','ðŸ­','ðŸ¹','ðŸ°','ðŸ¦Š','ðŸ»','ðŸ¼','ðŸ¨','ðŸ¯','ðŸ¦','ðŸ®','ðŸ·','ðŸ½','ðŸ¸','ðŸµ','ðŸ™ˆ','ðŸ™‰','ðŸ™Š','ðŸ’','ðŸ”','ðŸ§','ðŸ¦','ðŸ¤','ðŸ£','ðŸ¥','ðŸ¦†','ðŸ¦…','ðŸ¦‰','ðŸ¦‡','ðŸº','ðŸ—','ðŸ´','ðŸ¦„','ðŸ','ðŸª±','ðŸ›','ðŸ¦‹','ðŸŒ','ðŸž','ðŸœ','ðŸª°','ðŸª²','ðŸª³','ðŸ¦Ÿ','ðŸ¦—','ðŸ•·ï¸','ðŸ•¸ï¸','ðŸ¦‚','ðŸ¢','ðŸ','ðŸ¦Ž','ðŸ¦–','ðŸ¦•','ðŸ™','ðŸ¦‘','ðŸ¦','ðŸ¦ž','ðŸ¦€','ðŸ¡','ðŸ ','ðŸŸ','ðŸ¬','ðŸ³','ðŸ‹','ðŸ¦ˆ','ðŸŠ','ðŸ…','ðŸ†','ðŸ¦“','ðŸ¦','ðŸ¦§','ðŸ¦£','ðŸ˜','ðŸ¦›','ðŸ¦','ðŸª','ðŸ«','ðŸ¦’','ðŸ¦˜','ðŸ¦¬','ðŸƒ','ðŸ‚','ðŸ„','ðŸŽ','ðŸ–','ðŸ','ðŸ‘','ðŸ¦™','ðŸ','ðŸ¦Œ','ðŸ•','ðŸ©','ðŸ¦®','ðŸ•â€ðŸ¦º','ðŸˆ','ðŸˆâ€â¬›','ðŸª¶','ðŸ“','ðŸ¦ƒ','ðŸ¦¤','ðŸ¦š','ðŸ¦œ','ðŸ¦¢','ðŸ¦©','ðŸ•Šï¸','ðŸ‡','ðŸ¦','ðŸ¦¨','ðŸ¦¡','ðŸ¦«','ðŸ¦¦','ðŸ¦¥','ðŸ','ðŸ€','ðŸ¿ï¸','ðŸ¦”','ðŸ¾','ðŸ‰','ðŸ²','ðŸŒµ','ðŸŽ„','ðŸŒ²','ðŸŒ³','ðŸŒ´','ðŸªµ','ðŸŒ±','ðŸŒ¿','â˜˜ï¸','ðŸ€','ðŸŽ','ðŸª´','ðŸŽ‹','ðŸƒ','ðŸ‚','ðŸ','ðŸ„','ðŸš','ðŸª¨','ðŸŒ¾','ðŸ’','ðŸŒ·','ðŸŒ¹','ðŸ¥€','ðŸª·','ðŸŒº','ðŸŒ¸','ðŸŒ¼','ðŸŒ»','ðŸŒž','ðŸŒ','ðŸŒ›','ðŸŒœ','ðŸŒš','ðŸŒ•','ðŸŒ–','ðŸŒ—','ðŸŒ˜','ðŸŒ‘','ðŸŒ’','ðŸŒ“','ðŸŒ”','ðŸŒ™','ðŸŒŽ','ðŸŒ','ðŸŒ','ðŸª','ðŸ’«','â­','ðŸŒŸ','âœ¨','âš¡','â˜„ï¸','ðŸ’¥','ðŸ”¥','ðŸŒªï¸','ðŸŒˆ','â˜€ï¸','ðŸŒ¤ï¸','â›…','ðŸŒ¥ï¸','â˜ï¸','ðŸŒ¦ï¸','ðŸŒ§ï¸','â›ˆï¸','ðŸŒ©ï¸','ðŸŒ¨ï¸','â„ï¸','â˜ƒï¸','â›„','ðŸŒ¬ï¸','ðŸ’¨','ðŸ’§','ðŸ’¦','â˜”','â˜‚ï¸','ðŸŒŠ','ðŸŒ«ï¸'],
            'Food & Drink': ['ðŸ','ðŸŽ','ðŸ','ðŸŠ','ðŸ‹','ðŸŒ','ðŸ‰','ðŸ‡','ðŸ“','ðŸ«','ðŸˆ','ðŸ’','ðŸ‘','ðŸ¥­','ðŸ','ðŸ¥¥','ðŸ¥','ðŸ…','ðŸ†','ðŸ¥‘','ðŸ¥¦','ðŸ¥¬','ðŸ¥’','ðŸŒ¶ï¸','ðŸ«‘','ðŸŒ½','ðŸ¥•','ðŸ«’','ðŸ§„','ðŸ§…','ðŸ¥”','ðŸ ','ðŸ¥','ðŸ¥¯','ðŸž','ðŸ¥–','ðŸ¥¨','ðŸ§€','ðŸ¥š','ðŸ³','ðŸ§ˆ','ðŸ¥ž','ðŸ§‡','ðŸ¥“','ðŸ¥©','ðŸ—','ðŸ–','ðŸ¦´','ðŸŒ­','ðŸ”','ðŸŸ','ðŸ•','ðŸ«“','ðŸ¥ª','ðŸ¥™','ðŸ§†','ðŸŒ®','ðŸŒ¯','ðŸ«”','ðŸ¥—','ðŸ¥˜','ðŸ«•','ðŸ¥«','ðŸ','ðŸœ','ðŸ²','ðŸ›','ðŸ£','ðŸ±','ðŸ¥Ÿ','ðŸ¦ª','ðŸ¤','ðŸ™','ðŸš','ðŸ˜','ðŸ¥','ðŸ¥ ','ðŸ¥®','ðŸ¢','ðŸ¡','ðŸ§','ðŸ¨','ðŸ¦','ðŸ¥§','ðŸ§','ðŸ°','ðŸŽ‚','ðŸ®','ðŸ­','ðŸ¬','ðŸ«','ðŸ¿','ðŸ©','ðŸª','ðŸŒ°','ðŸ¥œ','ðŸ¯','ðŸ¥›','ðŸ¼','ðŸ«–','â˜•','ðŸµ','ðŸ§ƒ','ðŸ¥¤','ðŸ§‹','ðŸ¶','ðŸº','ðŸ»','ðŸ¥‚','ðŸ·','ðŸ¥ƒ','ðŸ¸','ðŸ¹','ðŸ§‰','ðŸ¾','ðŸ§Š','ðŸ¥„','ðŸ´','ðŸ½ï¸','ðŸ¥£','ðŸ¥¡','ðŸ¥¢','ðŸ§‚'],
            'Travel & Places': ['ðŸš—','ðŸš•','ðŸš™','ðŸšŒ','ðŸšŽ','ðŸŽï¸','ðŸš“','ðŸš‘','ðŸš’','ðŸš','ðŸ›»','ðŸšš','ðŸš›','ðŸšœ','ðŸ¦¯','ðŸ¦½','ðŸ¦¼','ðŸ›´','ðŸš²','ðŸ›µ','ðŸï¸','ðŸ›º','ðŸš¨','ðŸš”','ðŸš','ðŸš˜','ðŸš–','ðŸš¡','ðŸš ','ðŸšŸ','ðŸšƒ','ðŸš‹','ðŸšž','ðŸš','ðŸš„','ðŸš…','ðŸšˆ','ðŸš‚','ðŸš†','ðŸš‡','ðŸšŠ','ðŸš‰','âœˆï¸','ðŸ›«','ðŸ›¬','ðŸ›©ï¸','ðŸ’º','ðŸ›°ï¸','ðŸš€','ðŸ›¸','ðŸš','ðŸ›¶','â›µ','ðŸš¤','ðŸ›¥ï¸','ðŸ›³ï¸','â›´ï¸','ðŸš¢','âš“','ðŸª','â›½','ðŸš§','ðŸš¦','ðŸš¥','ðŸš','ðŸ—ºï¸','ðŸ—¿','ðŸ—½','ðŸ—¼','ðŸ°','ðŸ¯','ðŸŸï¸','ðŸŽ¡','ðŸŽ¢','ðŸŽ ','â›²','â›±ï¸','ðŸ–ï¸','ðŸï¸','ðŸœï¸','ðŸŒ‹','â›°ï¸','ðŸ”ï¸','ðŸ—»','ðŸ•ï¸','â›º','ðŸ›–','ðŸ ','ðŸ¡','ðŸ˜ï¸','ðŸšï¸','ðŸ—ï¸','ðŸ­','ðŸ¢','ðŸ¬','ðŸ£','ðŸ¤','ðŸ¥','ðŸ¦','ðŸ¨','ðŸª','ðŸ«','ðŸ©','ðŸ’’','ðŸ›ï¸','â›ª','ðŸ•Œ','ðŸ•','ðŸ›•','ðŸ•‹','â›©ï¸','ðŸ›¤ï¸','ðŸ›£ï¸','ðŸ—¾','ðŸŽ‘','ðŸžï¸','ðŸŒ…','ðŸŒ„','ðŸŒ ','ðŸŽ‡','ðŸŽ†','ðŸŒ‡','ðŸŒ†','ðŸ™ï¸','ðŸŒƒ','ðŸŒŒ','ðŸŒ‰','ðŸŒ'],
            'Activities': ['âš½','ðŸ€','ðŸˆ','âš¾','ðŸ¥Ž','ðŸŽ¾','ðŸ','ðŸ‰','ðŸ¥','ðŸŽ±','ðŸª€','ðŸ“','ðŸ¸','ðŸ’','ðŸ‘','ðŸ¥','ðŸ','ðŸªƒ','ðŸ¥…','â›³','ðŸª','ðŸ¹','ðŸŽ£','ðŸ¤¿','ðŸ¥Š','ðŸ¥‹','ðŸŽ½','ðŸ›¹','ðŸ›¼','ðŸ›·','â›¸ï¸','ðŸ¥Œ','ðŸŽ¿','â›·ï¸','ðŸ‚','ðŸª‚','ðŸ‹ï¸','ðŸ¤¼','ðŸ¤¸','ðŸ¤º','ðŸ¤¾','ðŸŒï¸','ðŸ‡','ðŸ§˜','ðŸ„','ðŸŠ','ðŸ¤½','ðŸš£','ðŸ§—','ðŸšµ','ðŸš´','ðŸ†','ðŸ¥‡','ðŸ¥ˆ','ðŸ¥‰','ðŸ…','ðŸŽ–ï¸','ðŸµï¸','ðŸŽ—ï¸','ðŸŽ«','ðŸŽŸï¸','ðŸŽª','ðŸ¤¹','ðŸŽ­','ðŸ©°','ðŸŽ¨','ðŸŽ¬','ðŸŽ¤','ðŸŽ§','ðŸŽ¼','ðŸŽ¹','ðŸ¥','ðŸª˜','ðŸŽ·','ðŸŽº','ðŸª—','ðŸŽ¸','ðŸª•','ðŸŽ»','ðŸŽ²','â™Ÿï¸','ðŸŽ¯','ðŸŽ³','ðŸŽ®','ðŸŽ°','ðŸ§©'],
            'Objects': ['âŒš','ðŸ“±','ðŸ“²','ðŸ’»','âŒ¨ï¸','ðŸ–¥ï¸','ðŸ–¨ï¸','ðŸ–±ï¸','ðŸ–²ï¸','ðŸ•¹ï¸','ðŸ—œï¸','ðŸ’¾','ðŸ’¿','ðŸ“€','ðŸ“¼','ðŸ“·','ðŸ“¸','ðŸ“¹','ðŸŽ¥','ðŸ“½ï¸','ðŸŽžï¸','ðŸ“ž','â˜Žï¸','ðŸ“Ÿ','ðŸ“ ','ðŸ“º','ðŸ“»','ðŸŽ™ï¸','ðŸŽšï¸','ðŸŽ›ï¸','ðŸ§­','â±ï¸','â²ï¸','â°','ðŸ•°ï¸','âŒ›','â³','ðŸ“¡','ðŸ”‹','ðŸ”Œ','ðŸ’¡','ðŸ”¦','ðŸ•¯ï¸','ðŸª”','ðŸ§¯','ðŸ›¢ï¸','ðŸ’¸','ðŸ’µ','ðŸ’´','ðŸ’¶','ðŸ’·','ðŸª™','ðŸ’°','ðŸ’³','ðŸ’Ž','âš–ï¸','ðŸªœ','ðŸ§°','ðŸª›','ðŸ”§','ðŸ”¨','âš’ï¸','ðŸ› ï¸','â›ï¸','ðŸªš','ðŸ”©','âš™ï¸','ðŸª¤','ðŸ§±','â›“ï¸','ðŸ§²','ðŸ”«','ðŸ’£','ðŸ§¨','ðŸª“','ðŸ”ª','ðŸ—¡ï¸','âš”ï¸','ðŸ›¡ï¸','ðŸš¬','âš°ï¸','ðŸª¦','âš±ï¸','ðŸº','ðŸ”®','ðŸ“¿','ðŸ§¿','ðŸ’ˆ','âš—ï¸','ðŸ”­','ðŸ”¬','ðŸ•³ï¸','ðŸ©¹','ðŸ©º','ðŸ’Š','ðŸ’‰','ðŸ©¸','ðŸ§¬','ðŸ¦ ','ðŸ§«','ðŸ§ª','ðŸŒ¡ï¸','ðŸ§¹','ðŸª ','ðŸ§º','ðŸ§»','ðŸš½','ðŸš°','ðŸš¿','ðŸ›','ðŸ›€','ðŸ§¼','ðŸª¥','ðŸª’','ðŸ§½','ðŸª£','ðŸ§´','ðŸ›Žï¸','ðŸ”‘','ðŸ—ï¸','ðŸšª','ðŸª‘','ðŸ›‹ï¸','ðŸ›ï¸','ðŸ›Œ','ðŸ§¸','ðŸª†','ðŸ–¼ï¸','ðŸªž','ðŸªŸ','ðŸ›ï¸','ðŸ›’','ðŸŽ','ðŸŽˆ','ðŸŽ','ðŸŽ€','ðŸª„','ðŸª…','ðŸŽŠ','ðŸŽ‰','ðŸŽŽ','ðŸ®','ðŸŽ','ðŸ§§','âœ‰ï¸','ðŸ“©','ðŸ“¨','ðŸ“§','ðŸ’Œ','ðŸ“¥','ðŸ“¤','ðŸ“¦','ðŸ·ï¸','ðŸª§','ðŸ“ª','ðŸ“«','ðŸ“¬','ðŸ“­','ðŸ“®','ðŸ“¯','ðŸ“œ','ðŸ“ƒ','ðŸ“„','ðŸ“‘','ðŸ§¾','ðŸ“Š','ðŸ“ˆ','ðŸ“‰','ðŸ—’ï¸','ðŸ—“ï¸','ðŸ“†','ðŸ“…','ðŸ—‘ï¸','ðŸ“‡','ðŸ—ƒï¸','ðŸ—³ï¸','ðŸ—„ï¸','ðŸ“‹','ðŸ“','ðŸ“‚','ðŸ—‚ï¸','ðŸ—žï¸','ðŸ“°','ðŸ““','ðŸ“”','ðŸ“’','ðŸ“•','ðŸ“—','ðŸ“˜','ðŸ“™','ðŸ“š','ðŸ“–','ðŸ”–','ðŸ§·','ðŸ”—','ðŸ“Ž','ðŸ–‡ï¸','ðŸ“','ðŸ“','ðŸ§®','ðŸ“Œ','ðŸ“','âœ‚ï¸','ðŸ–Šï¸','ðŸ–‹ï¸','âœ’ï¸','ðŸ–Œï¸','ðŸ–ï¸','ðŸ“','âœï¸','ðŸ”','ðŸ”Ž','ðŸ”','ðŸ”','ðŸ”’','ðŸ”“'],
            'Symbols': ['â¤ï¸','ðŸ§¡','ðŸ’›','ðŸ’š','ðŸ’™','ðŸ’œ','ðŸ–¤','ðŸ¤','ðŸ¤Ž','ðŸ’”','â£ï¸','ðŸ’•','ðŸ’ž','ðŸ’“','ðŸ’—','ðŸ’–','ðŸ’˜','ðŸ’','ðŸ’Ÿ','â˜®ï¸','âœï¸','â˜ªï¸','ðŸ•‰ï¸','â˜¸ï¸','âœ¡ï¸','ðŸ”¯','ðŸ•Ž','â˜¯ï¸','â˜¦ï¸','ðŸ›','â›Ž','â™ˆ','â™‰','â™Š','â™‹','â™Œ','â™','â™Ž','â™','â™','â™‘','â™’','â™“','ðŸ†”','âš›ï¸','ðŸ‰‘','â˜¢ï¸','â˜£ï¸','ðŸ“´','ðŸ“³','ðŸˆ¶','ðŸˆš','ðŸˆ¸','ðŸˆº','ðŸˆ·ï¸','âœ´ï¸','ðŸ†š','ðŸ’®','ðŸ‰','ãŠ™ï¸','ãŠ—ï¸','ðŸˆ´','ðŸˆµ','ðŸˆ¹','ðŸˆ²','ðŸ…°ï¸','ðŸ…±ï¸','ðŸ†Ž','ðŸ†‘','ðŸ…¾ï¸','ðŸ†˜','âŒ','â­•','ðŸ›‘','â›”','ðŸ“›','ðŸš«','ðŸ’¯','ðŸ’¢','â™¨ï¸','ðŸš·','ðŸš¯','ðŸš³','ðŸš±','ðŸ”ž','ðŸ“µ','ðŸš­','â—','â•','â“','â”','â€¼ï¸','â‰ï¸','ðŸ”…','ðŸ”†','ã€½ï¸','âš ï¸','ðŸš¸','ðŸ”±','âšœï¸','ðŸ”°','â™»ï¸','âœ…','ðŸˆ¯','ðŸ’¹','â‡ï¸','âœ³ï¸','âŽ','ðŸŒ','ðŸ’ ','â“‚ï¸','ðŸŒ€','ðŸ’¤','ðŸ§','ðŸš¾','â™¿','ðŸ…¿ï¸','ðŸ›—','ðŸˆ³','ðŸˆ‚ï¸','ðŸ›‚','ðŸ›ƒ','ðŸ›„','ðŸ›…','ðŸš¹','ðŸšº','ðŸš¼','âš§ï¸','ðŸš»','ðŸš®','ðŸŽ¦','ðŸ“¶','ðŸˆ','ðŸ”£','â„¹ï¸','ðŸ”¤','ðŸ”¡','ðŸ” ','ðŸ†–','ðŸ†—','ðŸ†™','ðŸ†’','ðŸ†•','ðŸ†“','0ï¸âƒ£','1ï¸âƒ£','2ï¸âƒ£','3ï¸âƒ£','4ï¸âƒ£','5ï¸âƒ£','6ï¸âƒ£','7ï¸âƒ£','8ï¸âƒ£','9ï¸âƒ£','ðŸ”Ÿ','ðŸ”¢','#ï¸âƒ£','*ï¸âƒ£','âï¸','â–¶ï¸','â¸ï¸','â¯ï¸','â¹ï¸','âºï¸','â­ï¸','â®ï¸','â©','âª','â«','â¬','â—€ï¸','ðŸ”¼','ðŸ”½','âž¡ï¸','â¬…ï¸','â¬†ï¸','â¬‡ï¸','â†—ï¸','â†˜ï¸','â†™ï¸','â†–ï¸','â†•ï¸','â†”ï¸','â†ªï¸','â†©ï¸','â¤´ï¸','â¤µï¸','ðŸ”€','ðŸ”','ðŸ”‚','ðŸ”„','ðŸ”ƒ','ðŸŽµ','ðŸŽ¶','âž•','âž–','âž—','âœ–ï¸','ðŸŸ°','â™¾ï¸','ðŸ’²','ðŸ’±','â„¢ï¸','Â©ï¸','Â®ï¸','ã€°ï¸','âž°','âž¿','ðŸ”š','ðŸ”™','ðŸ”›','ðŸ”','ðŸ”œ','âœ”ï¸','â˜‘ï¸','ðŸ”˜','ðŸ”´','ðŸŸ ','ðŸŸ¡','ðŸŸ¢','ðŸ”µ','ðŸŸ£','âš«','âšª','ðŸŸ¤','ðŸ”º','ðŸ”»','ðŸ”¸','ðŸ”¹','ðŸ”¶','ðŸ”·','ðŸ”³','ðŸ”²','â–ªï¸','â–«ï¸','â—¾','â—½','â—¼ï¸','â—»ï¸','ðŸŸ¥','ðŸŸ§','ðŸŸ¨','ðŸŸ©','ðŸŸ¦','ðŸŸª','â¬›','â¬œ','ðŸŸ«','ðŸ”ˆ','ðŸ”‡','ðŸ”‰','ðŸ”Š','ðŸ””','ðŸ”•','ðŸ“£','ðŸ“¢','ðŸ‘ï¸â€ðŸ—¨ï¸','ðŸ’¬','ðŸ’­','ðŸ—¯ï¸','â™ ï¸','â™£ï¸','â™¥ï¸','â™¦ï¸','ðŸƒ','ðŸŽ´','ðŸ€„','ðŸ•','ðŸ•‘','ðŸ•’','ðŸ•“','ðŸ•”','ðŸ••','ðŸ•–','ðŸ•—','ðŸ•˜','ðŸ•™','ðŸ•š','ðŸ•›','ðŸ•œ','ðŸ•','ðŸ•ž','ðŸ•Ÿ','ðŸ• ','ðŸ•¡','ðŸ•¢','ðŸ•£','ðŸ•¤','ðŸ•¥','ðŸ•¦','ðŸ•§'],
            'Flags': ['ðŸ³ï¸','ðŸ´','ðŸ','ðŸš©','ðŸ³ï¸â€ðŸŒˆ','ðŸ³ï¸â€âš§ï¸','ðŸ´â€â˜ ï¸','ðŸ‡¦ðŸ‡¨','ðŸ‡¦ðŸ‡©','ðŸ‡¦ðŸ‡ª','ðŸ‡¦ðŸ‡«','ðŸ‡¦ðŸ‡¬','ðŸ‡¦ðŸ‡®','ðŸ‡¦ðŸ‡±','ðŸ‡¦ðŸ‡²','ðŸ‡¦ðŸ‡´','ðŸ‡¦ðŸ‡¶','ðŸ‡¦ðŸ‡·','ðŸ‡¦ðŸ‡¸','ðŸ‡¦ðŸ‡¹','ðŸ‡¦ðŸ‡º','ðŸ‡¦ðŸ‡¼','ðŸ‡¦ðŸ‡½','ðŸ‡¦ðŸ‡¿','ðŸ‡§ðŸ‡¦','ðŸ‡§ðŸ‡§','ðŸ‡§ðŸ‡©','ðŸ‡§ðŸ‡ª','ðŸ‡§ðŸ‡«','ðŸ‡§ðŸ‡¬','ðŸ‡§ðŸ‡­','ðŸ‡§ðŸ‡®','ðŸ‡§ðŸ‡¯','ðŸ‡§ðŸ‡±','ðŸ‡§ðŸ‡²','ðŸ‡§ðŸ‡³','ðŸ‡§ðŸ‡´','ðŸ‡§ðŸ‡¶','ðŸ‡§ðŸ‡·','ðŸ‡§ðŸ‡¸','ðŸ‡§ðŸ‡¹','ðŸ‡§ðŸ‡»','ðŸ‡§ðŸ‡¼','ðŸ‡§ðŸ‡¾','ðŸ‡§ðŸ‡¿','ðŸ‡¨ðŸ‡¦','ðŸ‡¨ðŸ‡¨','ðŸ‡¨ðŸ‡©','ðŸ‡¨ðŸ‡«','ðŸ‡¨ðŸ‡¬','ðŸ‡¨ðŸ‡­','ðŸ‡¨ðŸ‡®','ðŸ‡¨ðŸ‡°','ðŸ‡¨ðŸ‡±','ðŸ‡¨ðŸ‡²','ðŸ‡¨ðŸ‡³','ðŸ‡¨ðŸ‡´','ðŸ‡¨ðŸ‡µ','ðŸ‡¨ðŸ‡·','ðŸ‡¨ðŸ‡º','ðŸ‡¨ðŸ‡»','ðŸ‡¨ðŸ‡¼','ðŸ‡¨ðŸ‡½','ðŸ‡¨ðŸ‡¾','ðŸ‡¨ðŸ‡¿','ðŸ‡©ðŸ‡ª','ðŸ‡©ðŸ‡¬','ðŸ‡©ðŸ‡¯','ðŸ‡©ðŸ‡°','ðŸ‡©ðŸ‡²','ðŸ‡©ðŸ‡´','ðŸ‡©ðŸ‡¿','ðŸ‡ªðŸ‡¦','ðŸ‡ªðŸ‡¨','ðŸ‡ªðŸ‡ª','ðŸ‡ªðŸ‡¬','ðŸ‡ªðŸ‡­','ðŸ‡ªðŸ‡·','ðŸ‡ªðŸ‡¸','ðŸ‡ªðŸ‡¹','ðŸ‡ªðŸ‡º','ðŸ‡«ðŸ‡®','ðŸ‡«ðŸ‡¯','ðŸ‡«ðŸ‡°','ðŸ‡«ðŸ‡²','ðŸ‡«ðŸ‡´','ðŸ‡«ðŸ‡·','ðŸ‡¬ðŸ‡¦','ðŸ‡¬ðŸ‡§','ðŸ‡¬ðŸ‡©','ðŸ‡¬ðŸ‡ª','ðŸ‡¬ðŸ‡«','ðŸ‡¬ðŸ‡¬','ðŸ‡¬ðŸ‡­','ðŸ‡¬ðŸ‡®','ðŸ‡¬ðŸ‡±','ðŸ‡¬ðŸ‡²','ðŸ‡¬ðŸ‡³','ðŸ‡¬ðŸ‡µ','ðŸ‡¬ðŸ‡¶','ðŸ‡¬ðŸ‡·','ðŸ‡¬ðŸ‡¸','ðŸ‡¬ðŸ‡¹','ðŸ‡¬ðŸ‡º','ðŸ‡¬ðŸ‡¼','ðŸ‡¬ðŸ‡¾','ðŸ‡­ðŸ‡°','ðŸ‡­ðŸ‡²','ðŸ‡­ðŸ‡³','ðŸ‡­ðŸ‡·','ðŸ‡­ðŸ‡¹','ðŸ‡­ðŸ‡º','ðŸ‡®ðŸ‡¨','ðŸ‡®ðŸ‡©','ðŸ‡®ðŸ‡ª','ðŸ‡®ðŸ‡±','ðŸ‡®ðŸ‡²','ðŸ‡®ðŸ‡³','ðŸ‡®ðŸ‡´','ðŸ‡®ðŸ‡¶','ðŸ‡®ðŸ‡·','ðŸ‡®ðŸ‡¸','ðŸ‡®ðŸ‡¹','ðŸ‡¯ðŸ‡ª','ðŸ‡¯ðŸ‡²','ðŸ‡¯ðŸ‡´','ðŸ‡¯ðŸ‡µ','ðŸ‡°ðŸ‡ª','ðŸ‡°ðŸ‡¬','ðŸ‡°ðŸ‡­','ðŸ‡°ðŸ‡®','ðŸ‡°ðŸ‡²','ðŸ‡°ðŸ‡³','ðŸ‡°ðŸ‡µ','ðŸ‡°ðŸ‡·','ðŸ‡°ðŸ‡¼','ðŸ‡°ðŸ‡¾','ðŸ‡°ðŸ‡¿','ðŸ‡±ðŸ‡¦','ðŸ‡±ðŸ‡§','ðŸ‡±ðŸ‡¨','ðŸ‡±ðŸ‡®','ðŸ‡±ðŸ‡°','ðŸ‡±ðŸ‡·','ðŸ‡±ðŸ‡¸','ðŸ‡±ðŸ‡¹','ðŸ‡±ðŸ‡º','ðŸ‡±ðŸ‡»','ðŸ‡±ðŸ‡¾','ðŸ‡²ðŸ‡¦','ðŸ‡²ðŸ‡¨','ðŸ‡²ðŸ‡©','ðŸ‡²ðŸ‡ª','ðŸ‡²ðŸ‡«','ðŸ‡²ðŸ‡¬','ðŸ‡²ðŸ‡­','ðŸ‡²ðŸ‡°','ðŸ‡²ðŸ‡±','ðŸ‡²ðŸ‡²','ðŸ‡²ðŸ‡³','ðŸ‡²ðŸ‡´','ðŸ‡²ðŸ‡µ','ðŸ‡²ðŸ‡¶','ðŸ‡²ðŸ‡·','ðŸ‡²ðŸ‡¸','ðŸ‡²ðŸ‡¹','ðŸ‡²ðŸ‡º','ðŸ‡²ðŸ‡»','ðŸ‡²ðŸ‡¼','ðŸ‡²ðŸ‡½','ðŸ‡²ðŸ‡¾','ðŸ‡²ðŸ‡¿','ðŸ‡³ðŸ‡¦','ðŸ‡³ðŸ‡¨','ðŸ‡³ðŸ‡ª','ðŸ‡³ðŸ‡«','ðŸ‡³ðŸ‡¬','ðŸ‡³ðŸ‡®','ðŸ‡³ðŸ‡±','ðŸ‡³ðŸ‡´','ðŸ‡³ðŸ‡µ','ðŸ‡³ðŸ‡·','ðŸ‡³ðŸ‡º','ðŸ‡³ðŸ‡¿','ðŸ‡´ðŸ‡²','ðŸ‡µðŸ‡¦','ðŸ‡µðŸ‡ª','ðŸ‡µðŸ‡«','ðŸ‡µðŸ‡¬','ðŸ‡µðŸ‡­','ðŸ‡µðŸ‡°','ðŸ‡µðŸ‡±','ðŸ‡µðŸ‡²','ðŸ‡µðŸ‡³','ðŸ‡µðŸ‡·','ðŸ‡µðŸ‡¸','ðŸ‡µðŸ‡¹','ðŸ‡µðŸ‡¼','ðŸ‡µðŸ‡¾','ðŸ‡¶ðŸ‡¦','ðŸ‡·ðŸ‡ª','ðŸ‡·ðŸ‡´','ðŸ‡·ðŸ‡¸','ðŸ‡·ðŸ‡º','ðŸ‡·ðŸ‡¼','ðŸ‡¸ðŸ‡¦','ðŸ‡¸ðŸ‡§','ðŸ‡¸ðŸ‡¨','ðŸ‡¸ðŸ‡©','ðŸ‡¸ðŸ‡ª','ðŸ‡¸ðŸ‡¬','ðŸ‡¸ðŸ‡­','ðŸ‡¸ðŸ‡®','ðŸ‡¸ðŸ‡¯','ðŸ‡¸ðŸ‡°','ðŸ‡¸ðŸ‡±','ðŸ‡¸ðŸ‡²','ðŸ‡¸ðŸ‡³','ðŸ‡¸ðŸ‡´','ðŸ‡¸ðŸ‡·','ðŸ‡¸ðŸ‡¸','ðŸ‡¸ðŸ‡¹','ðŸ‡¸ðŸ‡»','ðŸ‡¸ðŸ‡½','ðŸ‡¸ðŸ‡¾','ðŸ‡¸ðŸ‡¿','ðŸ‡¹ðŸ‡¦','ðŸ‡¹ðŸ‡¨','ðŸ‡¹ðŸ‡©','ðŸ‡¹ðŸ‡«','ðŸ‡¹ðŸ‡¬','ðŸ‡¹ðŸ‡­','ðŸ‡¹ðŸ‡¯','ðŸ‡¹ðŸ‡°','ðŸ‡¹ðŸ‡±','ðŸ‡¹ðŸ‡²','ðŸ‡¹ðŸ‡³','ðŸ‡¹ðŸ‡´','ðŸ‡¹ðŸ‡·','ðŸ‡¹ðŸ‡¹','ðŸ‡¹ðŸ‡»','ðŸ‡¹ðŸ‡¼','ðŸ‡¹ðŸ‡¿','ðŸ‡ºðŸ‡¦','ðŸ‡ºðŸ‡¬','ðŸ‡ºðŸ‡²','ðŸ‡ºðŸ‡³','ðŸ‡ºðŸ‡¸','ðŸ‡ºðŸ‡¾','ðŸ‡ºðŸ‡¿','ðŸ‡»ðŸ‡¦','ðŸ‡»ðŸ‡¨','ðŸ‡»ðŸ‡ª','ðŸ‡»ðŸ‡¬','ðŸ‡»ðŸ‡®','ðŸ‡»ðŸ‡³','ðŸ‡»ðŸ‡º','ðŸ‡¼ðŸ‡«','ðŸ‡¼ðŸ‡¸','ðŸ‡½ðŸ‡°','ðŸ‡¾ðŸ‡ª','ðŸ‡¾ðŸ‡¹','ðŸ‡¿ðŸ‡¦','ðŸ‡¿ðŸ‡²','ðŸ‡¿ðŸ‡¼','ðŸ´ó §ó ¢ó ¥ó ®ó §ó ¿','ðŸ´ó §ó ¢ó ³ó £ó ´ó ¿','ðŸ´ó §ó ¢ó ·ó ¬ó ³ó ¿']
        };

        let currentEmojiCategory = null;
        let currentSelectedEmoji = 'ðŸ˜€';

        function openEmojiModal(categoryKey) {
            currentEmojiCategory = categoryKey;
            const emojiModal = document.getElementById('emojiModal');
            const emojiGridContainer = document.getElementById('emojiGridContainer');
            
            // Get current emoji if exists
            const preview = document.getElementById(`emoji-preview-${categoryKey}`);
            if (preview) {
                currentSelectedEmoji = preview.textContent;
            }
            
            // Populate emoji grid
            emojiGridContainer.innerHTML = '';
            for (const [category, emojis] of Object.entries(allEmojis)) {
                const section = document.createElement('div');
                section.className = 'emoji-category-section';
                
                const title = document.createElement('div');
                title.className = 'emoji-category-title';
                title.textContent = category;
                section.appendChild(title);
                
                const grid = document.createElement('div');
                grid.className = 'emoji-grid';
                
                emojis.forEach(emoji => {
                    const item = document.createElement('div');
                    item.className = 'emoji-item';
                    if (emoji === currentSelectedEmoji) {
                        item.classList.add('selected');
                    }
                    item.textContent = emoji;
                    item.addEventListener('click', () => selectEmojiFromModal(emoji));
                    grid.appendChild(item);
                });
                
                section.appendChild(grid);
                emojiGridContainer.appendChild(section);
            }
            
            emojiModal.classList.add('show');
        }

        function closeEmojiModal() {
            document.getElementById('emojiModal').classList.remove('show');
        }

        function selectEmojiFromModal(emoji) {
            currentSelectedEmoji = emoji;
            
            // Update all emoji items
            document.querySelectorAll('.emoji-item').forEach(item => {
                item.classList.remove('selected');
                if (item.textContent === emoji) {
                    item.classList.add('selected');
                }
            });
            
            // Update preview in form
            if (currentEmojiCategory) {
                const preview = document.getElementById(`emoji-preview-${currentEmojiCategory}`);
                if (preview) {
                    preview.textContent = emoji;
                }
                selectedEmojis[currentEmojiCategory] = emoji;
            }
            
            closeEmojiModal();
        }

        // Setup emoji modal close button
        document.addEventListener('DOMContentLoaded', function() {
            const closeBtn = document.getElementById('emojiModalClose');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeEmojiModal);
            }
            
            const emojiModal = document.getElementById('emojiModal');
            if (emojiModal) {
                emojiModal.addEventListener('click', function(e) {
                    if (e.target === emojiModal) {
                        closeEmojiModal();
                    }
                });
            }
        });

        function toggleCategory(categoryKey) {
            userSettings[categoryKey].enabled = !userSettings[categoryKey].enabled;
            document.getElementById(`toggle-${categoryKey}`).classList.toggle('active');
            document.getElementById(`options-${categoryKey}`).style.display = 
                userSettings[categoryKey].enabled ? 'block' : 'none';
            autoSaveSettings(); // Auto-save changes
        }

        function toggleOption(categoryKey, optionId) {
            const option = userSettings[categoryKey].options.find(o => o.id === optionId);
            if (option) {
                // Toggle enabled state - works for both default and custom options
                option.enabled = option.enabled === false ? true : false;
                renderCustomization();
                autoSaveSettings(); // Auto-save changes
            }
        }

        function removeOption(categoryKey, optionId) {
            const index = userSettings[categoryKey].options.findIndex(o => o.id === optionId);
            if (index > -1 && !userSettings[categoryKey].options[index].default) {
                const option = userSettings[categoryKey].options[index];
                
                // Warning confirmation dialog
                const confirmed = confirm(
                    `âš ï¸ DELETE OPTION WARNING âš ï¸\n\n` +
                    `You are about to permanently delete "${option.label}".\n\n` +
                    `This action:\n` +
                    `â€¢ Removes "${option.label}" from your tracking options\n` +
                    `â€¢ CANNOT be undone or recovered\n` +
                    `â€¢ Does NOT delete existing mood data that includes it\n\n` +
                    `Delete "${option.label}" permanently?`
                );
                
                if (!confirmed) return;
                
                userSettings[categoryKey].options.splice(index, 1);
                renderCustomization();
                autoSaveSettings(); // Auto-save changes
                showToast(`âœ… "${option.label}" deleted`);
            }
        }

        function editOption(categoryKey, optionId) {
            const option = userSettings[categoryKey].options.find(o => o.id === optionId);
            if (!option) return;

            // Create edit modal
            const modalHTML = `
                <div class="modal-overlay" id="editOptionModal" style="display: flex;">
                    <div class="modal" style="max-width: 400px;">
                        <div class="modal-header">
                            <div class="modal-date">Edit Option</div>
                            <button class="modal-close" onclick="closeEditModal()">Ã—</button>
                        </div>
                        <div style="padding: 24px;">
                            <div class="form-group" style="margin-bottom: 20px;">
                                <label class="form-label">Name</label>
                                <input type="text" class="form-input" id="editOptionName" value="${option.label}" placeholder="e.g., Swimming">
                            </div>
                            <div class="form-group" style="margin-bottom: 20px;">
                                <label class="form-label">Emoji</label>
                                <button type="button" class="form-input" id="editOptionEmojiBtn" style="cursor: pointer; text-align: left; font-size: 1.5rem; display: flex; align-items: center; gap: 8px;">
                                    <span id="editOptionEmojiPreview">${option.emoji}</span>
                                    <span style="font-size: 0.9rem; color: var(--text-secondary);">Click to change</span>
                                </button>
                            </div>
                            <div class="form-actions">
                                <button class="form-btn cancel" onclick="closeEditModal()">Cancel</button>
                                <button class="form-btn save" onclick="saveEditedOption('${categoryKey}', '${optionId}')">Save Changes</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Add modal to page
            document.body.insertAdjacentHTML('beforeend', modalHTML);

            // Store current emoji for editing
            window.editingOptionEmoji = option.emoji;

            // Add emoji picker listener
            document.getElementById('editOptionEmojiBtn').addEventListener('click', () => {
                openEmojiModalForEdit();
            });
        }

        function closeEditModal() {
            const modal = document.getElementById('editOptionModal');
            if (modal) modal.remove();
            window.editingOptionEmoji = null;
        }
        window.closeEditModal = closeEditModal;

        function saveEditedOption(categoryKey, optionId) {
            const option = userSettings[categoryKey].options.find(o => o.id === optionId);
            if (!option) return;

            const newName = document.getElementById('editOptionName').value.trim();
            const newEmoji = window.editingOptionEmoji || option.emoji;

            if (!newName) {
                showToast('âš ï¸ Please enter a name', true);
                return;
            }

            option.label = newName;
            option.emoji = newEmoji;

            closeEditModal();
            renderCustomization();
            showToast('âœ… Option updated!');
            autoSaveSettings();
        }
        window.saveEditedOption = saveEditedOption;

        function openEmojiModalForEdit() {
            const emojiModal = document.getElementById('emojiModal');
            const emojiGridContainer = document.getElementById('emojiGridContainer');
            
            // Populate emoji grid
            emojiGridContainer.innerHTML = '';
            for (const [category, emojis] of Object.entries(allEmojis)) {
                const section = document.createElement('div');
                section.className = 'emoji-category-section';
                
                const title = document.createElement('div');
                title.className = 'emoji-category-title';
                title.textContent = category;
                section.appendChild(title);
                
                const grid = document.createElement('div');
                grid.className = 'emoji-grid';
                
                emojis.forEach(emoji => {
                    const item = document.createElement('div');
                    item.className = 'emoji-item';
                    if (emoji === window.editingOptionEmoji) {
                        item.classList.add('selected');
                    }
                    item.textContent = emoji;
                    item.addEventListener('click', () => {
                        window.editingOptionEmoji = emoji;
                        document.getElementById('editOptionEmojiPreview').textContent = emoji;
                        // Update selection
                        document.querySelectorAll('.emoji-item').forEach(i => i.classList.remove('selected'));
                        item.classList.add('selected');
                        closeEmojiModal();
                    });
                    grid.appendChild(item);
                });
                
                section.appendChild(grid);
                emojiGridContainer.appendChild(section);
            }
            
            emojiModal.classList.add('show');
        }

        function showAddOptionForm(categoryKey) {
            document.getElementById(`form-${categoryKey}`).classList.add('show');
        }

        function hideAddOptionForm(categoryKey) {
            document.getElementById(`form-${categoryKey}`).classList.remove('show');
            document.getElementById(`input-name-${categoryKey}`).value = '';
            // Reset emoji preview to default
            const preview = document.getElementById(`emoji-preview-${categoryKey}`);
            if (preview) {
                preview.textContent = 'ðŸ˜€';
            }
            selectedEmojis[categoryKey] = 'ðŸ˜€';
        }

        let selectedEmojis = {};

        function addCustomOption(categoryKey) {
            const name = document.getElementById(`input-name-${categoryKey}`).value.trim();
            const emoji = selectedEmojis[categoryKey] || 'ðŸ˜€';

            if (!name) {
                showToast('âš ï¸ Please enter a name', true);
                return;
            }

            const newOption = {
                id: name.toLowerCase().replace(/\s+/g, '_') + '_' + Date.now(),
                emoji: emoji,
                label: name,
                default: false,
                enabled: true
            };

            userSettings[categoryKey].options.push(newOption);
            hideAddOptionForm(categoryKey);
            renderCustomization();
            showToast(`âœ… Added "${name}" to ${categoryKey}!`);
            autoSaveSettings(); // Auto-save changes
        }

        // Data Functions
        async function saveMoodData(dateKey, moodData) {
            // Demo mode - save to in-memory storage only
            if (isDemoMode) {
                demoMoodData[dateKey] = moodData;
                console.log('Demo mode: Saved to memory:', dateKey);
                return;
            }

            if (!currentUser) {
                console.error('No user logged in');
                throw new Error('No user logged in');
            }

            // Owner mode - save to localStorage as backup
            localStorage.setItem(`mood_${dateKey}`, JSON.stringify(moodData));

            try {
                // Save to Firestore
                const docRef = doc(db, 'users', currentUser.uid, 'moods', dateKey);
                await setDoc(docRef, moodData, { merge: true });
                console.log('Successfully saved to Firestore:', dateKey);
            } catch (error) {
                console.error('Error saving to Firestore:', error);
                // Data is still in localStorage, so it's not lost
                throw error;
            }
        }

        async function getMoodData(dateKey) {
            // Demo mode - get from in-memory storage
            if (isDemoMode) {
                return demoMoodData[dateKey] || null;
            }

            if (!currentUser) {
                console.log('No user logged in, checking localStorage');
                const localData = localStorage.getItem(`mood_${dateKey}`);
                return localData ? JSON.parse(localData) : null;
            }

            try {
                // Try Firestore first
                const docRef = doc(db, 'users', currentUser.uid, 'moods', dateKey);
                const docSnap = await getDoc(docRef);
                
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // Cache in localStorage
                    localStorage.setItem(`mood_${dateKey}`, JSON.stringify(data));
                    return data;
                }
            } catch (error) {
                console.error('Error getting from Firestore:', error);
            }
            
            // Fallback to localStorage
            const localData = localStorage.getItem(`mood_${dateKey}`);
            return localData ? JSON.parse(localData) : null;
        }

        async function getAllMoodData(startDate, endDate) {
            // Demo mode - get from in-memory storage
            if (isDemoMode) {
                const allData = [];
                for (const [dateKey, data] of Object.entries(demoMoodData)) {
                    const date = new Date(dateKey);
                    if (date >= new Date(startDate) && date <= new Date(endDate)) {
                        allData.push({ date: dateKey, ...data });
                    }
                }
                return allData;
            }

            if (!currentUser) return [];

            try {
                const moodsRef = collection(db, 'users', currentUser.uid, 'moods');
                const querySnapshot = await getDocs(moodsRef);
                
                const allData = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const date = new Date(doc.id);
                    if (date >= new Date(startDate) && date <= new Date(endDate)) {
                        allData.push({ date: doc.id, ...data });
                    }
                });
                
                return allData;
            } catch (error) {
                console.error('Error getting all mood data:', error);
                // Fallback to localStorage
                const allData = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('mood_')) {
                        const dateKey = key.replace('mood_', '');
                        const date = new Date(dateKey);
                        if (date >= new Date(startDate) && date <= new Date(endDate)) {
                            const data = JSON.parse(localStorage.getItem(key));
                            allData.push({ date: dateKey, ...data });
                        }
                    }
                }
                return allData;
            }
        }

        // Calendar Functions
        async function loadMoodData(year, month) {
            monthTitle.textContent = new Date(year, month).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            await renderCalendar(year, month);
        }

        async function renderCalendar(year, month) {
            calendar.innerHTML = '';

            const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            dayHeaders.forEach(day => {
                const header = document.createElement('div');
                header.className = 'day-header';
                header.textContent = day;
                calendar.appendChild(header);
            });

            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const daysInPrevMonth = new Date(year, month, 0).getDate();

            for (let i = firstDay - 1; i >= 0; i--) {
                const day = createDayElement(year, month - 1, daysInPrevMonth - i, true);
                calendar.appendChild(day);
            }

            for (let i = 1; i <= daysInMonth; i++) {
                const day = createDayElement(year, month, i, false);
                calendar.appendChild(day);
            }

            const remainingDays = 42 - (firstDay + daysInMonth);
            for (let i = 1; i <= remainingDays; i++) {
                const day = createDayElement(year, month + 1, i, true);
                calendar.appendChild(day);
            }
        }

        function createDayElement(year, month, dayNum, isOtherMonth) {
            const day = document.createElement('div');
            day.className = 'day';
            if (isOtherMonth) day.classList.add('other-month');

            const date = new Date(year, month, dayNum);
            const today = new Date();
            if (date.toDateString() === today.toDateString()) {
                day.classList.add('today');
            }

            const dayNumber = document.createElement('div');
            dayNumber.className = 'day-number';
            dayNumber.textContent = dayNum;
            day.appendChild(dayNumber);

            if (!isOtherMonth) {
                const dateKey = date.toISOString().split('T')[0];
                
                getMoodData(dateKey).then(moodData => {
                    if (moodData && moodData.mood) {
                        const moodEmoji = document.createElement('div');
                        moodEmoji.className = 'day-mood';
                        moodEmoji.textContent = moodEmojis[moodData.mood];
                        day.appendChild(moodEmoji);
                        day.setAttribute('data-mood', moodData.mood);
                        day.classList.add('has-mood');
                    }
                });

                day.addEventListener('click', () => openModal(date));
            }

            return day;
        }

        function openModal(date) {
            selectedDate = date;
            const dateKey = date.toISOString().split('T')[0];
            
            modalDate.textContent = date.toLocaleDateString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });

            // Clear previous selections
            document.querySelectorAll('.mood-option').forEach(option => option.classList.remove('selected'));
            noteInput.value = '';

            // Render dynamic sections based on user settings
            renderModalSections();

            getMoodData(dateKey).then(moodData => {
                if (moodData) {
                    if (moodData.mood) {
                        document.querySelector(`.mood-option[data-mood="${moodData.mood}"]`)?.classList.add('selected');
                    }
                    if (moodData.social) {
                        moodData.social.forEach(s => {
                            document.querySelector(`.social-option[data-id="${s}"]`)?.classList.add('selected');
                        });
                    }
                    if (moodData.weather) {
                        // Handle both array (new) and single value (old data)
                        const weatherArray = Array.isArray(moodData.weather) ? moodData.weather : [moodData.weather];
                        weatherArray.forEach(w => {
                            document.querySelector(`.weather-option[data-id="${w}"]`)?.classList.add('selected');
                        });
                    }
                    if (moodData.activities) {
                        moodData.activities.forEach(a => {
                            document.querySelector(`.activity-option[data-id="${a}"]`)?.classList.add('selected');
                        });
                    }
                    if (moodData.factors) {
                        moodData.factors.forEach(f => {
                            document.querySelector(`.factor-option[data-id="${f}"]`)?.classList.add('selected');
                        });
                    }
                    if (moodData.sleep) {
                        document.querySelector(`.sleep-option[data-id="${moodData.sleep}"]`)?.classList.add('selected');
                    }
                    if (moodData.sleepTime) {
                        const sleepTimeSelect = document.getElementById('sleepTimeSelect');
                        if (sleepTimeSelect) sleepTimeSelect.value = moodData.sleepTime;
                    }
                    if (moodData.wakeTime) {
                        const wakeTimeSelect = document.getElementById('wakeTimeSelect');
                        if (wakeTimeSelect) wakeTimeSelect.value = moodData.wakeTime;
                    }
                    // Update sleep duration display if both times exist
                    if (moodData.sleepTime && moodData.wakeTime) {
                        updateSleepDuration();
                    }
                    if (moodData.note) {
                        noteInput.value = moodData.note;
                    }
                }
            });

            modalOverlay.classList.add('show');
        }

        function renderModalSections() {
            // Render People section
            if (userSettings.people.enabled) {
                const peopleOptions = userSettings.people.options.filter(o => o.enabled !== false);
                let html = '<div class="detail-section"><h3 class="section-title">Who were you with?</h3><div class="detail-options" id="socialOptions">';
                peopleOptions.forEach(option => {
                    html += `
                        <div class="detail-option social-option" data-id="${option.id}">
                            <div class="detail-emoji">${option.emoji}</div>
                            <div class="detail-label">${option.label}</div>
                        </div>
                    `;
                });
                html += '</div></div>';
                document.getElementById('dynamicSocialSection').innerHTML = html;
                document.getElementById('dynamicSocialSection').style.display = 'block';
            } else {
                document.getElementById('dynamicSocialSection').style.display = 'none';
            }

            // Render Weather section
            if (userSettings.weather.enabled) {
                const weatherOptions = userSettings.weather.options.filter(o => o.enabled !== false);
                let html = '<div class="detail-section"><h3 class="section-title">Weather</h3><div class="detail-options" id="weatherOptions">';
                weatherOptions.forEach(option => {
                    html += `
                        <div class="detail-option weather-option" data-id="${option.id}">
                            <div class="detail-emoji">${option.emoji}</div>
                            <div class="detail-label">${option.label}</div>
                        </div>
                    `;
                });
                html += '</div></div>';
                document.getElementById('dynamicWeatherSection').innerHTML = html;
                document.getElementById('dynamicWeatherSection').style.display = 'block';
            } else {
                document.getElementById('dynamicWeatherSection').style.display = 'none';
            }

            // Render Activities section
            if (userSettings.activities.enabled) {
                const activityOptions = userSettings.activities.options.filter(o => o.enabled !== false);
                let html = '<div class="detail-section"><h3 class="section-title">Activities</h3><div class="detail-options" id="activityOptions">';
                activityOptions.forEach(option => {
                    html += `
                        <div class="detail-option activity-option" data-id="${option.id}">
                            <div class="detail-emoji">${option.emoji}</div>
                            <div class="detail-label">${option.label}</div>
                        </div>
                    `;
                });
                html += '</div></div>';
                document.getElementById('dynamicActivitySection').innerHTML = html;
                document.getElementById('dynamicActivitySection').style.display = 'block';
            } else {
                document.getElementById('dynamicActivitySection').style.display = 'none';
            }

            // Render Factors section
            if (userSettings.factors.enabled) {
                const factorOptions = userSettings.factors.options.filter(o => o.enabled !== false);
                let html = '<div class="detail-section"><h3 class="section-title">Factors</h3><div class="detail-options" id="factorOptions">';
                factorOptions.forEach(option => {
                    html += `
                        <div class="detail-option factor-option" data-id="${option.id}">
                            <div class="detail-emoji">${option.emoji}</div>
                            <div class="detail-label">${option.label}</div>
                        </div>
                    `;
                });
                html += '</div></div>';
                document.getElementById('dynamicFactorSection').innerHTML = html;
                document.getElementById('dynamicFactorSection').style.display = 'block';
            } else {
                document.getElementById('dynamicFactorSection').style.display = 'none';
            }

            // Render Sleep Time section
            let sleepTimeHtml = `
                <div class="detail-section">
                    <h3 class="section-title">Sleep Time</h3>
                    <div style="display: grid; gap: 16px;">
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <label style="font-weight: 600; color: var(--text-primary);">ðŸ˜´ Sleep Time</label>
                            <select id="sleepTimeSelect" class="time-select" style="padding: 12px; border-radius: 12px; border: 2px solid var(--bg-secondary); font-family: 'Nunito', sans-serif; font-size: 1rem; background: white; cursor: pointer;">
                                <option value="">Not recorded</option>
                            </select>
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <label style="font-weight: 600; color: var(--text-primary);">â° Wake Time</label>
                            <select id="wakeTimeSelect" class="time-select" style="padding: 12px; border-radius: 12px; border: 2px solid var(--bg-secondary); font-family: 'Nunito', sans-serif; font-size: 1rem; background: white; cursor: pointer;">
                                <option value="">Not recorded</option>
                            </select>
                        </div>
                        <div id="sleepDuration" style="padding: 12px; background: var(--bg-secondary); border-radius: 12px; text-align: center; font-weight: 600; color: var(--text-primary); display: none;">
                        </div>
                    </div>
                </div>
            `;
            document.getElementById('dynamicSleepTimeSection').innerHTML = sleepTimeHtml;
            
            // Populate time options (15-minute intervals)
            const sleepTimeSelect = document.getElementById('sleepTimeSelect');
            const wakeTimeSelect = document.getElementById('wakeTimeSelect');
            
            // Populate sleep time starting at 10 PM (22:00)
            for (let i = 0; i < 96; i++) { // 96 = 24 hours * 4 (15-min intervals)
                const totalMinutes = (22 * 60 + i * 15) % (24 * 60); // Start at 10 PM
                const hour = Math.floor(totalMinutes / 60);
                const minute = totalMinutes % 60;
                
                const timeValue = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
                const displayTime = formatTime(hour, minute);
                
                const sleepOption = document.createElement('option');
                sleepOption.value = timeValue;
                sleepOption.textContent = displayTime;
                sleepTimeSelect.appendChild(sleepOption);
            }
            
            // Populate wake time starting at 6 AM (06:00)
            for (let i = 0; i < 96; i++) { // 96 = 24 hours * 4 (15-min intervals)
                const totalMinutes = (6 * 60 + i * 15) % (24 * 60); // Start at 6 AM
                const hour = Math.floor(totalMinutes / 60);
                const minute = totalMinutes % 60;
                
                const timeValue = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
                const displayTime = formatTime(hour, minute);
                
                const wakeOption = document.createElement('option');
                wakeOption.value = timeValue;
                wakeOption.textContent = displayTime;
                wakeTimeSelect.appendChild(wakeOption);
            }
            
            // Add event listeners to calculate sleep duration
            sleepTimeSelect.addEventListener('change', updateSleepDuration);
            wakeTimeSelect.addEventListener('change', updateSleepDuration);

            // Render Sleep Quality section
            if (userSettings.sleep.enabled) {
                const sleepOptions = userSettings.sleep.options.filter(o => o.enabled !== false);
                let html = '<div class="detail-section"><h3 class="section-title">Sleep Quality</h3><div class="detail-options" id="sleepOptions">';
                sleepOptions.forEach(option => {
                    html += `
                        <div class="detail-option sleep-option" data-id="${option.id}">
                            <div class="detail-emoji">${option.emoji}</div>
                            <div class="detail-label">${option.label}</div>
                        </div>
                    `;
                });
                html += '</div></div>';
                document.getElementById('dynamicSleepSection').innerHTML = html;
                document.getElementById('dynamicSleepSection').style.display = 'block';
            } else {
                document.getElementById('dynamicSleepSection').style.display = 'none';
            }

            // Re-attach event listeners for dynamically created elements
            attachModalEventListeners();
        }

        // Helper function to format time for display
        function formatTime(hour, minute) {
            const period = hour >= 12 ? 'PM' : 'AM';
            const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
            return `${displayHour}:${String(minute).padStart(2, '0')} ${period}`;
        }

        // Helper function to calculate sleep duration
        function updateSleepDuration() {
            const sleepTime = document.getElementById('sleepTimeSelect').value;
            const wakeTime = document.getElementById('wakeTimeSelect').value;
            const durationDiv = document.getElementById('sleepDuration');
            
            if (sleepTime && wakeTime) {
                const [sleepHour, sleepMin] = sleepTime.split(':').map(Number);
                const [wakeHour, wakeMin] = wakeTime.split(':').map(Number);
                
                let sleepMinutes = sleepHour * 60 + sleepMin;
                let wakeMinutes = wakeHour * 60 + wakeMin;
                
                // If wake time is earlier, it means next day
                if (wakeMinutes <= sleepMinutes) {
                    wakeMinutes += 24 * 60;
                }
                
                const durationMinutes = wakeMinutes - sleepMinutes;
                const hours = Math.floor(durationMinutes / 60);
                const minutes = durationMinutes % 60;
                
                durationDiv.textContent = `ðŸ’¤ Sleep Duration: ${hours}h ${minutes}m`;
                durationDiv.style.display = 'block';
            } else {
                durationDiv.style.display = 'none';
            }
        }

        function attachModalEventListeners() {
            // Social options (multi-choice)
            document.querySelectorAll('.social-option').forEach(option => {
                option.addEventListener('click', () => {
                    option.classList.toggle('selected');
                });
            });

            // Weather options (multi-choice)
            document.querySelectorAll('.weather-option').forEach(option => {
                option.addEventListener('click', () => {
                    option.classList.toggle('selected');
                });
            });

            // Activity options (multi-choice)
            document.querySelectorAll('.activity-option').forEach(option => {
                option.addEventListener('click', () => {
                    option.classList.toggle('selected');
                });
            });

            // Factor options (multi-choice)
            document.querySelectorAll('.factor-option').forEach(option => {
                option.addEventListener('click', () => {
                    option.classList.toggle('selected');
                });
            });

            // Sleep options (single choice)
            document.querySelectorAll('.sleep-option').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.sleep-option').forEach(o => o.classList.remove('selected'));
                    option.classList.add('selected');
                });
            });
        }

        function closeModal() {
            modalOverlay.classList.remove('show');
        }

        async function saveMood() {
            const selectedMood = document.querySelector('.mood-option.selected');
            if (!selectedMood) {
                showToast('âš ï¸ Please select a mood first!', true);
                return;
            }

            const mood = parseInt(selectedMood.dataset.mood);
            const social = Array.from(document.querySelectorAll('.social-option.selected'))
                .map(el => el.dataset.id);
            const weather = Array.from(document.querySelectorAll('.weather-option.selected'))
                .map(el => el.dataset.id);
            const activities = Array.from(document.querySelectorAll('.activity-option.selected'))
                .map(el => el.dataset.id);
            const factors = Array.from(document.querySelectorAll('.factor-option.selected'))
                .map(el => el.dataset.id);
            const sleep = document.querySelector('.sleep-option.selected')?.dataset.id || null;
            const note = noteInput.value.trim();
            
            // Get sleep time data
            const sleepTime = document.getElementById('sleepTimeSelect')?.value || null;
            const wakeTime = document.getElementById('wakeTimeSelect')?.value || null;
            
            // Calculate sleep duration if both times are provided
            let sleepDuration = null;
            if (sleepTime && wakeTime) {
                const [sleepHour, sleepMin] = sleepTime.split(':').map(Number);
                const [wakeHour, wakeMin] = wakeTime.split(':').map(Number);
                let sleepMinutes = sleepHour * 60 + sleepMin;
                let wakeMinutes = wakeHour * 60 + wakeMin;
                if (wakeMinutes <= sleepMinutes) {
                    wakeMinutes += 24 * 60;
                }
                sleepDuration = wakeMinutes - sleepMinutes; // in minutes
            }

            const dateKey = selectedDate.toISOString().split('T')[0];
            const moodData = { 
                mood, 
                social, 
                weather, 
                activities, 
                factors, 
                sleep, 
                sleepTime, 
                wakeTime, 
                sleepDuration,
                note, 
                timestamp: new Date().toISOString() 
            };

            try {
                updateSyncStatus('Syncing...', true);
                await saveMoodData(dateKey, moodData);
                updateSyncStatus('Synced');
                if (isDemoMode) {
                    showToast('ðŸŽ® Mood recorded (demo mode)');
                } else {
                    showToast('âœ¨ Mood saved successfully!');
                }
                closeModal();
                await loadMoodData(currentDate.getFullYear(), currentDate.getMonth());
            } catch (error) {
                console.error('Error saving mood:', error);
                updateSyncStatus('Synced');
                showToast('âœ… Mood saved locally!');
                closeModal();
                await loadMoodData(currentDate.getFullYear(), currentDate.getMonth());
            }
        }

        // Analytics Functions
        async function loadAllMoodData(startDate, endDate) {
            const allMoodData = await getAllMoodData(startDate, endDate);

            if (allMoodData.length === 0) {
                document.getElementById('totalDays').textContent = '0';
                document.getElementById('avgMood').textContent = '0.0';
                document.getElementById('bestDay').textContent = 'â€”';
                document.getElementById('moodConsistencyStat').textContent = 'â€”';
                return;
            }

            document.getElementById('totalDays').textContent = allMoodData.length;

            const avgMood = allMoodData.reduce((sum, d) => sum + d.mood, 0) / allMoodData.length;
            document.getElementById('avgMood').textContent = avgMood.toFixed(1);

            // Calculate best month (highest average mood per month)
            const monthMoods = {};
            allMoodData.forEach(d => {
                const date = new Date(d.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthMoods[monthKey]) {
                    monthMoods[monthKey] = [];
                }
                monthMoods[monthKey].push(d.mood);
            });
            
            let bestMonth = 'â€”';
            let bestAvg = 0;
            for (const [monthKey, moods] of Object.entries(monthMoods)) {
                const avg = moods.reduce((a, b) => a + b, 0) / moods.length;
                if (avg > bestAvg) {
                    bestAvg = avg;
                    const [year, month] = monthKey.split('-');
                    const date = new Date(year, parseInt(month) - 1);
                    bestMonth = date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                }
            }
            document.getElementById('bestDay').textContent = bestMonth;

            renderCharts(allMoodData);
        }

        // Chart Modification System (allows deleting specific bars)
        let chartModifyModes = {
            activity: false,
            weather: false,
            social: false,
            sleepQuality: false
        };

        function toggleChartModifyMode(chartType) {
            chartModifyModes[chartType] = !chartModifyModes[chartType];
            
            // Update button appearance
            const btn = event.target;
            btn.classList.toggle('active');
            
            // Show/hide warning
            const infoId = chartType === 'activity' ? 'activityChartModifyInfo' :
                          chartType === 'weather' ? 'weatherChartModifyInfo' :
                          chartType === 'social' ? 'socialChartModifyInfo' :
                          'sleepQualityChartModifyInfo';
            
            const infoEl = document.getElementById(infoId);
            if (infoEl) {
                infoEl.style.display = chartModifyModes[chartType] ? 'block' : 'none';
            }

            // Update cursor on chart
            const canvasId = chartType === 'activity' ? 'activityChart' :
                           chartType === 'weather' ? 'moodWeatherChart' :
                           chartType === 'social' ? 'socialChart' :
                           'sleepQualityChart';
            
            const canvas = document.getElementById(canvasId);
            if (canvas) {
                canvas.style.cursor = chartModifyModes[chartType] ? 'pointer' : 'default';
            }
        }
        window.toggleChartModifyMode = toggleChartModifyMode;

        async function deleteChartData(chartType, dataId, dataLabel) {
            // Confirmation dialog with strong warning - NON-REVERTABLE
            const confirmed = confirm(
                `âš ï¸ NON-REVERTABLE ACTION âš ï¸\n\n` +
                `You are about to PERMANENTLY delete "${dataLabel}".\n\n` +
                `This will:\n` +
                `â€¢ Remove "${dataLabel}" from this chart (the bar/column will disappear)\n` +
                `â€¢ Delete "${dataLabel}" from ALL your past mood entries that include it\n` +
                `â€¢ CANNOT be undone or recovered\n\n` +
                `Other data will remain intact. Only "${dataLabel}" will be removed.\n\n` +
                `Delete "${dataLabel}"?`
            );

            if (!confirmed) return;

            // Second confirmation
            const doubleConfirm = confirm(
                `âš ï¸ FINAL CONFIRMATION âš ï¸\n\n` +
                `Last chance to cancel!\n\n` +
                `This will permanently remove "${dataLabel}" and its data from:\n` +
                `â€¢ This chart (bar will disappear)\n` +
                `â€¢ All your mood entries\n\n` +
                `Really delete "${dataLabel}"?`
            );

            if (!doubleConfirm) return;

            try {
                showToast('ðŸ—‘ï¸ Deleting data...', false);

                // Determine which field to update based on chart type
                const fieldName = chartType === 'activity' ? 'activities' :
                                chartType === 'weather' ? 'weather' :
                                chartType === 'social' ? 'social' :
                                'sleep';

                // Get all mood data
                const startDate = '2020-01-01';
                const endDate = new Date().toISOString().split('T')[0];
                const allData = await getAllMoodData(startDate, endDate);

                let updatedCount = 0;

                // Update each mood entry
                for (const entry of allData) {
                    let needsUpdate = false;
                    const moodData = await getMoodData(entry.date);
                    
                    if (fieldName === 'weather' && moodData.weather) {
                        // Handle both array and single value
                        if (Array.isArray(moodData.weather)) {
                            const index = moodData.weather.indexOf(dataId);
                            if (index > -1) {
                                moodData.weather.splice(index, 1);
                                if (moodData.weather.length === 0) moodData.weather = [];
                                needsUpdate = true;
                            }
                        } else if (moodData.weather === dataId) {
                            moodData.weather = [];
                            needsUpdate = true;
                        }
                    } else if (fieldName === 'sleep' && moodData.sleep === dataId) {
                        moodData.sleep = null;
                        needsUpdate = true;
                    } else if (Array.isArray(moodData[fieldName])) {
                        const filteredArray = moodData[fieldName].filter(id => id !== dataId);
                        if (filteredArray.length !== moodData[fieldName].length) {
                            moodData[fieldName] = filteredArray;
                            needsUpdate = true;
                        }
                    }

                    if (needsUpdate) {
                        await saveMoodData(entry.date, moodData);
                        updatedCount++;
                    }
                }

                showToast(`âœ… Deleted "${dataLabel}" from ${updatedCount} mood entries!`);

                // Reload analytics
                const startDateInput = document.getElementById('startDate');
                const endDateInput = document.getElementById('endDate');
                await loadAllMoodData(startDateInput.value, endDateInput.value);

                // Turn off modify mode
                chartModifyModes[chartType] = false;
                const btn = document.querySelector(`button[onclick*="${chartType}"]`);
                if (btn) btn.classList.remove('active');
                const infoId = chartType + 'ChartModifyInfo';
                const infoEl = document.getElementById(infoId);
                if (infoEl) infoEl.style.display = 'none';

            } catch (error) {
                console.error('Error deleting chart data:', error);
                showToast('âŒ Error deleting data. Please try again.', true);
            }
        }

        // Calculate linear regression for trend line
        function calculateLinearRegression(data) {
            const n = data.length;
            if (n === 0) return { slope: 0, intercept: 0 };
            
            const sumX = data.reduce((sum, d) => sum + d.x, 0);
            const sumY = data.reduce((sum, d) => sum + d.y, 0);
            const sumXY = data.reduce((sum, d) => sum + d.x * d.y, 0);
            const sumX2 = data.reduce((sum, d) => sum + d.x * d.x, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return { slope, intercept };
        }
        
        // Statistical significance testing for bar charts
        // Uses Mann-Whitney U test (appropriate for ordinal data like mood ratings)
        function testCategorySignificance(categoryData, allData, alpha = 0.05) {
            if (categoryData.length < 2) return false; // Need at least 2 samples in category
            
            // Create comparison group (all data NOT in this category)
            // We need to exclude the exact instances that are in categoryData
            // Create a copy of allData and remove categoryData items one by one
            const allDataCopy = [...allData];
            const comparisonData = [];
            
            // Mark items from categoryData as used
            const categoryDataCopy = [...categoryData];
            
            for (let i = 0; i < allDataCopy.length; i++) {
                const val = allDataCopy[i];
                const indexInCategory = categoryDataCopy.indexOf(val);
                
                if (indexInCategory !== -1) {
                    // This value is in categoryData, remove it from our copy
                    categoryDataCopy.splice(indexInCategory, 1);
                } else {
                    // This value is NOT in categoryData, add to comparison
                    comparisonData.push(val);
                }
            }
            
            if (comparisonData.length < 2) return false; // Need at least 2 in comparison group
            
            // Mann-Whitney U test
            const n1 = categoryData.length;
            const n2 = comparisonData.length;
            
            // Combine and rank all data
            const combined = [
                ...categoryData.map(val => ({ value: val, group: 1 })),
                ...comparisonData.map(val => ({ value: val, group: 2 }))
            ];
            
            // Sort by value
            combined.sort((a, b) => a.value - b.value);
            
            // Assign ranks (handling ties with average rank)
            let i = 0;
            while (i < combined.length) {
                let j = i;
                // Find all items with same value
                while (j < combined.length && combined[j].value === combined[i].value) {
                    j++;
                }
                // Assign average rank to all tied items
                const avgRank = (i + 1 + j) / 2;
                for (let k = i; k < j; k++) {
                    combined[k].rank = avgRank;
                }
                i = j;
            }
            
            // Calculate sum of ranks for group 1 (category)
            const R1 = combined.filter(item => item.group === 1).reduce((sum, item) => sum + item.rank, 0);
            
            // Calculate U statistics
            const U1 = n1 * n2 + (n1 * (n1 + 1)) / 2 - R1;
            const U2 = n1 * n2 - U1;
            const U = Math.min(U1, U2);
            
            // For large samples (n1, n2 > 20), use normal approximation
            if (n1 > 20 && n2 > 20) {
                const meanU = (n1 * n2) / 2;
                const stdU = Math.sqrt((n1 * n2 * (n1 + n2 + 1)) / 12);
                const z = Math.abs((U - meanU) / stdU);
                
                // Critical z-values for two-tailed test
                const zCritical = getZCriticalValue(alpha);
                return z > zCritical;
            }
            
            // For small samples, use exact U critical values
            const UCritical = getUCriticalValue(n1, n2, alpha);
            return U <= UCritical; // Note: U test is significant when U is SMALL
        }
        
        // Critical z-values for normal approximation (large samples)
        function getZCriticalValue(alpha) {
            const zValues = {
                0.05: 1.96,   // 95% confidence (p<0.05)
                0.1: 1.645,   // 90% confidence (p<0.1)
                0.2: 1.282    // 80% confidence (p<0.2)
            };
            return zValues[alpha] || zValues[0.05];
        }
        
        // Critical U values for Mann-Whitney test (small samples)
        // Returns critical U value for given n1, n2, and alpha
        function getUCriticalValue(n1, n2, alpha) {
            // For simplicity, use approximation for small samples
            // This is a simplified table - in practice, would use complete tables
            
            // Ensure n1 <= n2 for table lookup
            if (n1 > n2) [n1, n2] = [n2, n1];
            
            // Approximate critical values (two-tailed)
            // These are conservative estimates
            if (alpha === 0.05) {
                // High significance (p<0.05)
                if (n1 <= 3 || n2 <= 3) return 0;
                if (n1 <= 10 && n2 <= 10) return Math.floor(n1 * n2 * 0.2);
                return Math.floor(n1 * n2 * 0.25);
            } else if (alpha === 0.1) {
                // Medium significance (p<0.1)
                if (n1 <= 3 || n2 <= 3) return 1;
                if (n1 <= 10 && n2 <= 10) return Math.floor(n1 * n2 * 0.3);
                return Math.floor(n1 * n2 * 0.35);
            } else if (alpha === 0.2) {
                // Low significance (p<0.2) - most lenient
                if (n1 <= 3 || n2 <= 3) return 2;
                if (n1 <= 10 && n2 <= 10) return Math.floor(n1 * n2 * 0.4);
                return Math.floor(n1 * n2 * 0.45);
            }
            
            // Default to 0.05
            return Math.floor(n1 * n2 * 0.25);
        }

        function renderCharts(allMoodData) {
            Object.values(charts).forEach(chart => chart.destroy());
            charts = {};

            // Get selected significance level
            const alphaValue = document.getElementById('significanceLevel').value;
            const useSignificance = alphaValue !== 'none';
            const alpha = useSignificance ? parseFloat(alphaValue) : 0.05;

            allMoodData.sort((a, b) => new Date(a.date) - new Date(b.date));

            // 1. Mood Trend
            const trendLabels = allMoodData.map(d => new Date(d.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
            const trendData = allMoodData.map(d => d.mood);

            const trendCtx = document.getElementById('moodTrendChart').getContext('2d');
            charts.trend = new Chart(trendCtx, {
                type: 'line',
                data: {
                    labels: trendLabels,
                    datasets: [{
                        label: 'Mood',
                        data: trendData,
                        borderColor: '#FF9B71',
                        backgroundColor: 'rgba(255, 155, 113, 0.1)',
                        tension: 0.4,
                        fill: true,
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            min: 0,
                            max: 5.5,
                            ticks: { 
                                stepSize: 1,
                                callback: function(value) {
                                    const moodEmojis = {
                                        1: 'ðŸ˜¢',
                                        2: 'ðŸ˜•',
                                        3: 'ðŸ˜',
                                        4: 'ðŸ™‚',
                                        5: 'ðŸ˜„'
                                    };
                                    return moodEmojis[value] || '';
                                }
                            }
                        },
                        x: {
                            ticks: { maxTicksLimit: 10 }
                        }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });

            // 2. Activity Impact - Dynamic based on recorded data
            const activityMoodData = {};
            allMoodData.forEach(d => {
                if (d.activities && d.activities.length > 0) {
                    d.activities.forEach(activityId => {
                        if (!activityMoodData[activityId]) {
                            activityMoodData[activityId] = [];
                        }
                        activityMoodData[activityId].push(d.mood);
                    });
                }
            });

            // Get all mood values for significance testing
            const allMoods = allMoodData.map(d => d.mood);

            // Calculate averages, test significance, and sort by mood (highest to lowest)
            const activityStats = Object.entries(activityMoodData)
                .map(([id, moods]) => {
                    const avg = moods.reduce((a, b) => a + b, 0) / moods.length;
                    const option = userSettings.activities.options.find(o => o.id === id);
                    const isSignificant = useSignificance ? testCategorySignificance(moods, allMoods, alpha) : true;
                    return {
                        id,
                        label: option ? `${option.emoji} ${option.label}` : id,
                        avg,
                        count: moods.length,
                        significant: isSignificant
                    };
                })
                .sort((a, b) => b.avg - a.avg); // Highest mood first

            if (activityStats.length > 0) {
                const activityLabels = activityStats.map(s => s.label);
                const activityAvgs = activityStats.map(s => s.avg);
                const activityColors = activityStats.map((stat, i) => {
                    const hue = (120 - (i * 120 / activityStats.length)); // Green to red gradient
                    const opacity = useSignificance ? (stat.significant ? 1.0 : 0.3) : 1.0;
                    return `hsla(${hue}, 60%, 65%, ${opacity})`;
                });

                const activityCtx = document.getElementById('activityChart').getContext('2d');
                charts.activity = new Chart(activityCtx, {
                    type: 'bar',
                    data: {
                        labels: activityLabels,
                        datasets: [{
                            label: 'Avg Mood',
                            data: activityAvgs,
                            backgroundColor: activityColors,
                            borderRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y', // Horizontal bars
                        scales: {
                            x: {
                                min: 0,
                                max: 5,
                                ticks: { stepSize: 1 }
                            },
                            y: {
                                ticks: {
                                    autoSkip: false,
                                    font: {
                                        size: activityLabels.length > 15 ? 8 : 11
                                    }
                                }
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (!useSignificance) return '';
                                        const stat = activityStats[context.dataIndex];
                                        return stat.significant ? `(Significant p<${alpha})` : '(Not significant)';
                                    }
                                }
                            }
                        },
                        onClick: (event, elements) => {
                            if (chartModifyModes.activity && elements.length > 0) {
                                const index = elements[0].index;
                                const stat = activityStats[index];
                                deleteChartData('activity', stat.id, stat.label);
                            }
                        }
                    }
                });
            }

            // 3. Weather Impact - Dynamic based on recorded data
            const weatherMoodData = {};
            allMoodData.forEach(d => {
                if (d.weather) {
                    // Handle both array (new) and single value (old data)
                    const weatherArray = Array.isArray(d.weather) ? d.weather : [d.weather];
                    weatherArray.forEach(weatherId => {
                        if (!weatherMoodData[weatherId]) {
                            weatherMoodData[weatherId] = [];
                        }
                        weatherMoodData[weatherId].push(d.mood);
                    });
                }
            });

            // Calculate averages, test significance, and sort by mood (highest to lowest)
            const weatherStats = Object.entries(weatherMoodData)
                .map(([id, moods]) => {
                    const avg = moods.reduce((a, b) => a + b, 0) / moods.length;
                    const option = userSettings.weather.options.find(o => o.id === id);
                    const isSignificant = useSignificance ? testCategorySignificance(moods, allMoods, alpha) : true;
                    return {
                        id,
                        label: option ? `${option.emoji} ${option.label}` : id,
                        avg,
                        count: moods.length,
                        significant: isSignificant
                    };
                })
                .sort((a, b) => b.avg - a.avg); // Highest mood first

            if (weatherStats.length > 0) {
                const weatherLabels = weatherStats.map(s => s.label);
                const weatherAvgs = weatherStats.map(s => s.avg);
                const weatherColors = weatherStats.map((stat, i) => {
                    const hue = (120 - (i * 120 / weatherStats.length));
                    const opacity = useSignificance ? (stat.significant ? 1.0 : 0.3) : 1.0;
                    return `hsla(${hue}, 60%, 65%, ${opacity})`;
                });

                const moodWeatherCtx = document.getElementById('moodWeatherChart').getContext('2d');
                charts.moodWeather = new Chart(moodWeatherCtx, {
                    type: 'bar',
                    data: {
                        labels: weatherLabels,
                        datasets: [{
                            label: 'Avg Mood',
                            data: weatherAvgs,
                            backgroundColor: weatherColors,
                            borderRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',  // Horizontal bars
                        scales: {
                            x: {
                                min: 0,
                                max: 5,
                                ticks: { stepSize: 1 }
                            },
                            y: {
                                ticks: {
                                    autoSkip: false,
                                    font: {
                                        size: weatherLabels.length > 15 ? 8 : 11
                                    }
                                }
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (!useSignificance) return '';
                                        const stat = weatherStats[context.dataIndex];
                                        return stat.significant ? `(Significant p<${alpha})` : '(Not significant)';
                                    }
                                }
                            }
                        },
                        onClick: (event, elements) => {
                            if (chartModifyModes.weather && elements.length > 0) {
                                const index = elements[0].index;
                                const stat = weatherStats[index];
                                deleteChartData('weather', stat.id, stat.label);
                            }
                        }
                    }
                });
            }

            // 4. Social/People Impact - Dynamic based on recorded data
            const socialMoodData = {};
            allMoodData.forEach(d => {
                if (d.social && d.social.length > 0) {
                    d.social.forEach(socialId => {
                        if (!socialMoodData[socialId]) {
                            socialMoodData[socialId] = [];
                        }
                        socialMoodData[socialId].push(d.mood);
                    });
                }
            });

            // Calculate averages, test significance, and sort by mood (highest to lowest)
            const socialStats = Object.entries(socialMoodData)
                .map(([id, moods]) => {
                    const avg = moods.reduce((a, b) => a + b, 0) / moods.length;
                    const option = userSettings.people.options.find(o => o.id === id);
                    const isSignificant = useSignificance ? testCategorySignificance(moods, allMoods, alpha) : true;
                    return {
                        id,
                        label: option ? `${option.emoji} ${option.label}` : id,
                        avg,
                        count: moods.length,
                        significant: isSignificant
                    };
                })
                .sort((a, b) => b.avg - a.avg); // Highest mood first

            if (socialStats.length > 0) {
                const socialLabels = socialStats.map(s => s.label);
                const socialAvgs = socialStats.map(s => s.avg);
                const socialColors = socialStats.map((stat, i) => {
                    const hue = (120 - (i * 120 / socialStats.length));
                    const opacity = useSignificance ? (stat.significant ? 1.0 : 0.3) : 1.0;
                    return `hsla(${hue}, 60%, 65%, ${opacity})`;
                });

                const socialCtx = document.getElementById('socialChart').getContext('2d');
                charts.social = new Chart(socialCtx, {
                    type: 'bar',
                    data: {
                        labels: socialLabels,
                        datasets: [{
                            label: 'Avg Mood',
                            data: socialAvgs,
                            backgroundColor: socialColors,
                            borderRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y',  // Horizontal bars
                        scales: {
                            x: {
                                min: 0,
                                max: 5,
                                ticks: { stepSize: 1 }
                            },
                            y: {
                                ticks: {
                                    autoSkip: false,
                                    font: {
                                        size: socialLabels.length > 15 ? 8 : 11
                                    }
                                }
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (!useSignificance) return '';
                                        const stat = socialStats[context.dataIndex];
                                        return stat.significant ? `(Significant p<${alpha})` : '(Not significant)';
                                    }
                                }
                            }
                        },
                        onClick: (event, elements) => {
                            if (chartModifyModes.social && elements.length > 0) {
                                const index = elements[0].index;
                                const stat = socialStats[index];
                                deleteChartData('social', stat.id, stat.label);
                            }
                        }
                    }
                });
            }

            // 5. Factors Impact - NEW
            const factorsMoodData = {};
            allMoodData.forEach(d => {
                if (d.factors && d.factors.length > 0) {
                    d.factors.forEach(factorId => {
                        if (!factorsMoodData[factorId]) {
                            factorsMoodData[factorId] = [];
                        }
                        factorsMoodData[factorId].push(d.mood);
                    });
                }
            });

            // Calculate averages, test significance, and sort by mood (highest to lowest)
            const factorsStats = Object.entries(factorsMoodData)
                .map(([id, moods]) => {
                    const avg = moods.reduce((a, b) => a + b, 0) / moods.length;
                    const option = userSettings.factors.options.find(o => o.id === id);
                    const isSignificant = useSignificance ? testCategorySignificance(moods, allMoods, alpha) : true;
                    return {
                        id,
                        label: option ? `${option.emoji} ${option.label}` : id,
                        avg,
                        count: moods.length,
                        significant: isSignificant
                    };
                })
                .sort((a, b) => b.avg - a.avg); // Highest mood first

            if (factorsStats.length > 0) {
                const factorsLabels = factorsStats.map(s => s.label);
                const factorsAvgs = factorsStats.map(s => s.avg);
                const factorsColors = factorsStats.map((stat, i) => {
                    const hue = (120 - (i * 120 / factorsStats.length));
                    const opacity = useSignificance ? (stat.significant ? 1.0 : 0.3) : 1.0;
                    return `hsla(${hue}, 60%, 65%, ${opacity})`;
                });

                const factorsCtx = document.getElementById('factorsChart').getContext('2d');
                charts.factors = new Chart(factorsCtx, {
                    type: 'bar',
                    data: {
                        labels: factorsLabels,
                        datasets: [{
                            label: 'Avg Mood',
                            data: factorsAvgs,
                            backgroundColor: factorsColors,
                            borderRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        indexAxis: 'y', // Horizontal bars
                        scales: {
                            x: {
                                min: 0,
                                max: 5,
                                ticks: { stepSize: 1 }
                            },
                            y: {
                                ticks: {
                                    autoSkip: false,
                                    font: {
                                        size: factorsLabels.length > 15 ? 8 : 11
                                    }
                                }
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (!useSignificance) return '';
                                        const stat = factorsStats[context.dataIndex];
                                        return stat.significant ? `(Significant p<${alpha})` : '(Not significant)';
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // 6. Sleep Schedule (Sleep Time & Wake Time) - NEW
            const sleepScheduleData = allMoodData
                .filter(d => d.sleepTime && d.wakeTime)
                .sort((a, b) => new Date(a.date) - new Date(b.date)); // Sort by date, no slice - respect date range
            
            if (sleepScheduleData.length > 0) {
                const labels = sleepScheduleData.map(d => {
                    const date = new Date(d.date);
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                });
                
                // Convert HH:MM to decimal hours
                const convertToDecimal = (timeStr) => {
                    const [hours, minutes] = timeStr.split(':').map(Number);
                    return hours + minutes / 60;
                };
                
                // Calculate sleep and wake times
                const sleepTimes = sleepScheduleData.map(d => {
                    let time = convertToDecimal(d.sleepTime);
                    // If sleep time is before noon, it's likely evening of previous day (add 24)
                    if (time < 12) time += 24;
                    return time;
                });
                
                const wakeTimes = sleepScheduleData.map(d => {
                    let sleepTime = convertToDecimal(d.sleepTime);
                    let wakeTime = convertToDecimal(d.wakeTime);
                    
                    // Normalize sleep time
                    if (sleepTime < 12) sleepTime += 24;
                    
                    // Wake time is next day, add 24 if it's earlier than normalized sleep
                    if (wakeTime < 12) {
                        wakeTime += 24;
                    }
                    
                    // If wake time is still less than sleep time, it must be the day after
                    if (wakeTime < sleepTime) {
                        wakeTime += 24;
                    }
                    
                    return wakeTime;
                });
                
                // Find dynamic y-axis range
                const minSleepTime = Math.min(...sleepTimes);
                const maxWakeTime = Math.max(...wakeTimes);
                const yAxisMin = Math.ceil(maxWakeTime) + 1; // Max wake time + 1 hour (reversed axis, so this is bottom)
                const yAxisMax = Math.floor(minSleepTime) - 1; // Min sleep time - 1 hour (reversed axis, so this is top)
                
                const sleepScheduleCanvas = document.getElementById('sleepScheduleChart');
                if (sleepScheduleCanvas) {
                    const sleepScheduleCtx = sleepScheduleCanvas.getContext('2d');
                    charts.sleepSchedule = new Chart(sleepScheduleCtx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Sleep Time',
                            data: sleepTimes,
                            borderColor: '#4A5FD9',
                            backgroundColor: 'rgba(107, 203, 119, 0.3)',
                            tension: 0.3,
                            fill: '+1', // Fill to next dataset (Wake Time)
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            borderWidth: 2,
                            order: 1
                        }, {
                            label: 'Wake Time',
                            data: wakeTimes,
                            borderColor: '#FFB84D',
                            backgroundColor: 'rgba(255, 184, 77, 0.1)',
                            tension: 0.3,
                            fill: false,
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            borderWidth: 2,
                            order: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                ticks: { 
                                    maxTicksLimit: 15,
                                    autoSkip: true
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Time of Day'
                                },
                                reverse: true,  // Flip axis: Sleep time on top, wake time on bottom
                                min: yAxisMin,
                                max: yAxisMax,
                                ticks: {
                                    stepSize: 2,
                                    callback: function(value) {
                                        const hour = value % 24;
                                        const period = hour >= 12 ? 'PM' : 'AM';
                                        const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
                                        return `${displayHour} ${period}`;
                                    }
                                }
                            }
                        },
                        plugins: {
                            legend: { 
                                display: true
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const value = context.parsed.y;
                                        const hour = Math.floor(value % 24);
                                        const minutes = Math.round((value % 1) * 60);
                                        const period = hour >= 12 ? 'PM' : 'AM';
                                        const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
                                        return `${context.dataset.label}: ${displayHour}:${String(minutes).padStart(2, '0')} ${period}`;
                                    }
                                }
                            }
                        }
                    }
                });
                }
            }


            // 10. Sleep Quality vs Mood - NEW
            const sleepQualityMoodData = {};
            allMoodData.forEach(d => {
                if (d.sleep) {
                    if (!sleepQualityMoodData[d.sleep]) {
                        sleepQualityMoodData[d.sleep] = [];
                    }
                    sleepQualityMoodData[d.sleep].push(d.mood);
                }
            });

            // Calculate averages and sort by mood (highest to lowest)
            const sleepQualityStats = Object.entries(sleepQualityMoodData)
                .map(([id, moods]) => {
                    const avg = moods.reduce((a, b) => a + b, 0) / moods.length;
                    const option = userSettings.sleep.options.find(o => o.id === id);
                    return {
                        id,
                        label: option ? `${option.emoji} ${option.label}` : id,
                        avg,
                        count: moods.length
                    };
                })
                .sort((a, b) => b.avg - a.avg); // Highest mood first

            if (sleepQualityStats.length > 0) {
                const sleepQualityLabels = sleepQualityStats.map(s => s.label);
                const sleepQualityAvgs = sleepQualityStats.map(s => s.avg);
                const sleepQualityColors = sleepQualityStats.map((_, i) => {
                    const hue = (120 - (i * 120 / sleepQualityStats.length));
                    return `hsl(${hue}, 60%, 65%)`;
                });

                const sleepQualityCanvas = document.getElementById('sleepQualityChart');
                if (sleepQualityCanvas) {
                    const sleepQualityCtx = sleepQualityCanvas.getContext('2d');
                    charts.sleepQuality = new Chart(sleepQualityCtx, {
                    type: 'bar',
                    data: {
                        labels: sleepQualityLabels,
                        datasets: [{
                            label: 'Avg Mood',
                            data: sleepQualityAvgs,
                            backgroundColor: sleepQualityColors,
                            borderRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                ticks: {
                                    autoSkip: false,
                                    font: {
                                        size: sleepQualityLabels.length > 15 ? 8 : 11
                                    }
                                }
                            },
                            y: {
                                min: 0,
                                max: 5,
                                ticks: { stepSize: 1 }
                            }
                        },
                        plugins: {
                            legend: { display: false }
                        },
                        onClick: (event, elements) => {
                            if (chartModifyModes.sleepQuality && elements.length > 0) {
                                const index = elements[0].index;
                                const stat = sleepQualityStats[index];
                                deleteChartData('sleepQuality', stat.id, stat.label);
                            }
                        }
                    }
                });
                }
            }

            // 11. Mood Distribution
            const moodDist = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
            allMoodData.forEach(d => moodDist[d.mood]++);
            const totalMoods = allMoodData.length;

            const moodDistCanvas = document.getElementById('moodDistChart');
            if (moodDistCanvas) {
                const moodDistCtx = moodDistCanvas.getContext('2d');
                charts.moodDist = new Chart(moodDistCtx, {
                type: 'doughnut',
                data: {
                    labels: ['ðŸ˜¢ Rough', 'ðŸ˜• Meh', 'ðŸ˜ Okay', 'ðŸ™‚ Good', 'ðŸ˜„ Great'],
                    datasets: [{
                        data: Object.values(moodDist),
                        backgroundColor: Object.values(moodColors),
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: { 
                                padding: 15,
                                boxWidth: 15,
                                font: { size: 12 },
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    return data.labels.map((label, i) => {
                                        const value = data.datasets[0].data[i];
                                        const percentage = totalMoods > 0 ? ((value / totalMoods) * 100).toFixed(1) : 0;
                                        return {
                                            text: `${label}: ${percentage}%`,
                                            fillStyle: data.datasets[0].backgroundColor[i],
                                            hidden: false,
                                            index: i
                                        };
                                    });
                                }
                            },
                            maxHeight: 60
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed;
                                    const percentage = totalMoods > 0 ? ((value / totalMoods) * 100).toFixed(1) : 0;
                                    return `${context.label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
            }

            // 12. Mood by Day of Week
            const dayMoods = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [] };
            allMoodData.forEach(d => {
                const date = new Date(d.date);
                dayMoods[date.getDay()].push(d.mood);
            });

            const dayLabels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const dayAvgs = dayLabels.map((_, i) => {
                const moods = dayMoods[i];
                return moods.length > 0 ? moods.reduce((a, b) => a + b, 0) / moods.length : 0;
            });

            const moodDayCanvas = document.getElementById('moodDayChart');
            if (moodDayCanvas) {
                const moodDayCtx = moodDayCanvas.getContext('2d');
                charts.moodDay = new Chart(moodDayCtx, {
                type: 'radar',
                data: {
                    labels: dayLabels,
                    datasets: [{
                        label: 'Avg Mood',
                        data: dayAvgs,
                        backgroundColor: 'rgba(255, 155, 113, 0.2)',
                        borderColor: '#FF9B71',
                        pointBackgroundColor: '#FF9B71',
                        pointRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            min: 0,
                            max: 5,
                            ticks: { stepSize: 1 }
                        }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
            }

            // 13. Mood Consistency - Updated Formula
            const sortedMoodData = [...allMoodData].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            if (sortedMoodData.length >= 8) {  // Need 7 days for average + 1 for first score
                const moodConsistencyScores = [];
                
                for (let i = 7; i < sortedMoodData.length; i++) {
                    const today = sortedMoodData[i];
                    const prev7Days = sortedMoodData.slice(i - 7, i);
                    
                    // Calculate 7-day average mood (excluding today)
                    const avgMood7d = prev7Days.reduce((sum, d) => sum + d.mood, 0) / 7;
                    
                    // Calculate daily deviation
                    const dailyDev = Math.abs(today.mood - avgMood7d);
                    
                    // Tiered scoring
                    let dailyScore;
                    if (dailyDev <= 0.5) {
                        // Green: Very consistent (100 â†’ 90)
                        dailyScore = 100 - (dailyDev / 0.5) * 10;
                    } else if (dailyDev <= 1.5) {
                        // Yellow: Mildly inconsistent (90 â†’ 60)
                        dailyScore = 90 - ((dailyDev - 0.5) / 1.0) * 30;
                    } else {
                        // Red: Inconsistent/volatile (60 â†’ 0)
                        dailyScore = Math.max(0, 60 - ((dailyDev - 1.5) / 2.5) * 60);
                    }
                    
                    moodConsistencyScores.push({
                        date: today.date,
                        score: dailyScore,
                        deviation: dailyDev,
                        mood: today.mood,
                        avgMood: avgMood7d
                    });
                }
                
                if (moodConsistencyScores.length > 0) {
                    // Calculate rolling 7-day average for gauge
                    const last7Scores = moodConsistencyScores.slice(-Math.min(7, moodConsistencyScores.length));
                    const finalScore = last7Scores.reduce((sum, s) => sum + s.score, 0) / last7Scores.length;
                    
                    // Update stat card
                    document.getElementById('moodConsistencyStat').textContent = `${Math.round(finalScore)}%`;
                    
                    // Store data globally for period switching
                    window.moodConsistencyData = moodConsistencyScores;
                    
                    // 1. Mood Consistency Gauge
                    const gaugeCanvas = document.getElementById('moodConsistencyGauge');
                    if (gaugeCanvas) {
                        const gaugeColor = finalScore >= 70 ? '#10b981' : finalScore >= 40 ? '#eab308' : '#ef4444';
                        
                        charts.moodConsistencyGauge = new Chart(gaugeCanvas.getContext('2d'), {
                            type: 'doughnut',
                            data: {
                                datasets: [{
                                    data: [finalScore, 100 - finalScore],
                                    backgroundColor: [gaugeColor, '#e5e7eb'],
                                    borderWidth: 0,
                                    circumference: 180,
                                    rotation: 270
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: true,
                                cutout: '75%',
                                plugins: {
                                    legend: { display: false },
                                    tooltip: { enabled: false }
                                }
                            },
                            plugins: [{
                                id: 'centerText',
                                afterDraw: (chart) => {
                                    const ctx = chart.ctx;
                                    const centerX = chart.chartArea.left + (chart.chartArea.right - chart.chartArea.left) / 2;
                                    const centerY = chart.chartArea.top + (chart.chartArea.bottom - chart.chartArea.top) / 2 + 20;
                                    
                                    ctx.save();
                                    ctx.font = 'bold 32px Quicksand';
                                    ctx.fillStyle = gaugeColor;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText(`${Math.round(finalScore)}%`, centerX, centerY);
                                    
                                    ctx.font = '12px Quicksand';
                                    ctx.fillStyle = '#6b7280';
                                    ctx.fillText(finalScore >= 70 ? 'Consistent' : finalScore >= 40 ? 'Moderate' : 'Volatile', centerX, centerY + 25);
                                    ctx.restore();
                                }
                            }]
                        });
                    }
                    
                    // 2. Mood Consistency Trend Chart
                    const moodConsistencyCanvas = document.getElementById('moodConsistencyChart');
                    if (moodConsistencyCanvas) {
                        renderMoodConsistencyChart('weekly');
                        
                        // Initialize button state
                        const chartCard = document.getElementById('moodConsistencyChart').closest('.chart-card');
                        if (chartCard) {
                            chartCard.querySelectorAll('.period-btn').forEach(btn => {
                                btn.classList.remove('active');
                                if (btn.dataset.period === 'weekly') btn.classList.add('active');
                            });
                        }
                    }
                }
            }
            
            // 14. What Happens on Days Before a Bad Mood?
            // Bad mood is defined as mood <= 3 (Rough, Meh, Okay)
            renderBadMoodPredictorsChart(allMoodData, useSignificance, alpha);
        }
        
        // Two-Proportion Z-Test
        // Tests H0: p1 = p2 vs Ha: p1 â‰  p2
        function twoProportionZTest(x1, n1, x2, n2, alpha) {
            // x1 = successes in group 1 (before bad mood)
            // n1 = total in group 1
            // x2 = successes in group 2 (all days)
            // n2 = total in group 2
            
            if (n1 === 0 || n2 === 0) return { significant: false, zScore: 0, pValue: 1 };
            
            const p1 = x1 / n1;
            const p2 = x2 / n2;
            
            // Pooled proportion
            const pPooled = (x1 + x2) / (n1 + n2);
            
            // Standard error
            const se = Math.sqrt(pPooled * (1 - pPooled) * (1/n1 + 1/n2));
            
            if (se === 0) return { significant: false, zScore: 0, pValue: 1 };
            
            // Z-score
            const z = (p1 - p2) / se;
            
            // Two-tailed p-value approximation using standard normal
            const pValue = 2 * (1 - normalCDF(Math.abs(z)));
            
            // Critical z-values for two-tailed test
            const zCritical = {
                0.05: 1.96,
                0.1: 1.645,
                0.2: 1.282
            }[alpha] || 1.96;
            
            return {
                significant: Math.abs(z) > zCritical,
                zScore: z,
                pValue: pValue
            };
        }
        
        // Standard normal CDF approximation
        function normalCDF(x) {
            const a1 =  0.254829592;
            const a2 = -0.284496736;
            const a3 =  1.421413741;
            const a4 = -1.453152027;
            const a5 =  1.061405429;
            const p  =  0.3275911;
            
            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x) / Math.sqrt(2);
            
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            
            return 0.5 * (1.0 + sign * y);
        }
        
        // Render Bad Mood Predictors Chart
        function renderBadMoodPredictorsChart(allMoodData, useSignificance, alpha) {
            const badMoodPredictorsCanvas = document.getElementById('badMoodPredictorsChart');
            if (!badMoodPredictorsCanvas) return;
            
            // Get significance settings if not passed
            if (useSignificance === undefined) {
                const alphaValue = document.getElementById('significanceLevel').value;
                useSignificance = alphaValue !== 'none';
                alpha = useSignificance ? parseFloat(alphaValue) : 0.05;
            }
            
            // Sort data by date
            const sortedData = [...allMoodData].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            if (sortedData.length < 2) {
                return;
            }
            
            // Define bad mood threshold (â‰¤3 means Rough=1, Meh=2, Okay=3)
            const BAD_MOOD_THRESHOLD = 3;
            
            // Track all days with lagged data and whether they precede bad mood
            const allLaggedDays = []; // Each entry: { precedesBadMood: bool, data: {...} }
            
            // Process each day to collect lagged features
            for (let i = 1; i < sortedData.length; i++) {
                const today = sortedData[i];
                const yesterday = sortedData[i - 1];
                
                // Check if dates are actually consecutive (within 2 days to be safe)
                const todayDate = new Date(today.date);
                const yesterdayDate = new Date(yesterday.date);
                const daysDiff = Math.floor((todayDate - yesterdayDate) / (1000 * 60 * 60 * 24));
                
                if (daysDiff > 2) continue;
                
                const precedesBadMood = today.mood <= BAD_MOOD_THRESHOLD;
                
                allLaggedDays.push({
                    precedesBadMood,
                    mood: yesterday.mood || null,
                    sleepDuration: yesterday.sleepDuration || null,
                    sleep: yesterday.sleep || null,
                    activities: yesterday.activities || [],
                    factors: yesterday.factors || [],
                    social: yesterday.social || [],
                    weather: yesterday.weather ? (Array.isArray(yesterday.weather) ? yesterday.weather : [yesterday.weather]) : []
                });
            }
            
            const n1 = allLaggedDays.filter(d => d.precedesBadMood).length; // Days before bad mood
            const n2 = allLaggedDays.length; // All days (total)
            
            if (n1 === 0 || n2 < 5) {
                const ctx = badMoodPredictorsCanvas.getContext('2d');
                ctx.clearRect(0, 0, badMoodPredictorsCanvas.width, badMoodPredictorsCanvas.height);
                ctx.font = '14px Nunito';
                ctx.fillStyle = '#8A8A8A';
                ctx.textAlign = 'center';
                ctx.fillText('Not enough data yet. Keep tracking to see patterns!', badMoodPredictorsCanvas.width / 2, badMoodPredictorsCanvas.height / 2);
                return;
            }
            
            const differences = [];
            
            // Helper to convert sleep quality to numeric
            const sleepQualityToNumeric = (sleepId) => {
                const sleepOption = userSettings.sleep.options.find(o => o.id === sleepId);
                if (!sleepOption) return null;
                const label = sleepOption.label.toLowerCase();
                if (label.includes('great') || label.includes('excellent') || label.includes('amazing')) return 5;
                if (label.includes('good') || label.includes('well')) return 4;
                if (label.includes('okay') || label.includes('fair') || label.includes('average')) return 3;
                if (label.includes('poor') || label.includes('bad')) return 2;
                if (label.includes('terrible') || label.includes('awful') || label.includes('worst')) return 1;
                const idx = userSettings.sleep.options.findIndex(o => o.id === sleepId);
                return idx >= 0 ? Math.min(5, idx + 1) : null;
            };
            
            // For numeric variables (mood, sleep duration, sleep quality), use simple averages
            // and a two-sample t-test approximation
            
            // Yesterday's Mood
            const moodBeforeBad = allLaggedDays.filter(d => d.precedesBadMood && d.mood).map(d => d.mood);
            const moodAll = allLaggedDays.filter(d => d.mood).map(d => d.mood);
            if (moodBeforeBad.length >= 3 && moodAll.length >= 3) {
                const avgBad = moodBeforeBad.reduce((a, b) => a + b, 0) / moodBeforeBad.length;
                const avgAll = moodAll.reduce((a, b) => a + b, 0) / moodAll.length;
                const diff = avgBad - avgAll;
                
                // For numeric, we'll use a simplified significance check based on effect size
                const significant = Math.abs(diff) > 0.3; // Meaningful difference threshold
                
                differences.push({
                    label: 'ðŸ˜Š Yesterday Mood',
                    diff: diff,
                    badAvg: avgBad,
                    normalAvg: avgAll,
                    type: 'numeric',
                    unit: '',
                    significant: significant,
                    testNote: 'Effect size'
                });
            }
            
            // Sleep Duration
            const sleepDurBeforeBad = allLaggedDays.filter(d => d.precedesBadMood && d.sleepDuration).map(d => d.sleepDuration / 60);
            const sleepDurAll = allLaggedDays.filter(d => d.sleepDuration).map(d => d.sleepDuration / 60);
            if (sleepDurBeforeBad.length >= 3 && sleepDurAll.length >= 3) {
                const avgBad = sleepDurBeforeBad.reduce((a, b) => a + b, 0) / sleepDurBeforeBad.length;
                const avgAll = sleepDurAll.reduce((a, b) => a + b, 0) / sleepDurAll.length;
                const diff = avgBad - avgAll;
                const significant = Math.abs(diff) > 0.5; // 30 min difference threshold
                
                differences.push({
                    label: 'ðŸ›ï¸ Sleep Duration (hrs)',
                    diff: diff,
                    badAvg: avgBad,
                    normalAvg: avgAll,
                    type: 'numeric',
                    unit: 'hrs',
                    significant: significant,
                    testNote: 'Effect size'
                });
            }
            
            // Sleep Quality
            const sleepQualBeforeBad = allLaggedDays.filter(d => d.precedesBadMood && d.sleep).map(d => sleepQualityToNumeric(d.sleep)).filter(v => v !== null);
            const sleepQualAll = allLaggedDays.filter(d => d.sleep).map(d => sleepQualityToNumeric(d.sleep)).filter(v => v !== null);
            if (sleepQualBeforeBad.length >= 3 && sleepQualAll.length >= 3) {
                const avgBad = sleepQualBeforeBad.reduce((a, b) => a + b, 0) / sleepQualBeforeBad.length;
                const avgAll = sleepQualAll.reduce((a, b) => a + b, 0) / sleepQualAll.length;
                const diff = avgBad - avgAll;
                const significant = Math.abs(diff) > 0.3;
                
                differences.push({
                    label: 'ðŸ’¤ Sleep Quality',
                    diff: diff,
                    badAvg: avgBad,
                    normalAvg: avgAll,
                    type: 'numeric',
                    unit: '',
                    significant: significant,
                    testNote: 'Effect size'
                });
            }
            
            // For categorical variables, use Two-Proportion Z-Test
            // p1 = proportion with factor on days before bad mood
            // p2 = proportion with factor on all days
            
            // Activities
            const allActivityIds = new Set();
            allLaggedDays.forEach(d => d.activities.forEach(id => allActivityIds.add(id)));
            
            allActivityIds.forEach(actId => {
                const x1 = allLaggedDays.filter(d => d.precedesBadMood && d.activities.includes(actId)).length;
                const x2 = allLaggedDays.filter(d => d.activities.includes(actId)).length;
                
                if (x2 < 2) return; // Need minimum occurrences
                
                const p1 = x1 / n1;
                const p2 = x2 / n2;
                const diff = (p1 - p2) * 100; // Convert to percentage points
                
                if (Math.abs(diff) < 1) return; // Skip tiny differences
                
                const testResult = twoProportionZTest(x1, n1, x2, n2, alpha);
                const option = userSettings.activities.options.find(o => o.id === actId);
                
                differences.push({
                    label: option ? `${option.emoji} ${option.label}` : actId,
                    diff: diff,
                    badAvg: p1 * 100,
                    normalAvg: p2 * 100,
                    type: 'rate',
                    unit: '%',
                    significant: testResult.significant,
                    zScore: testResult.zScore,
                    pValue: testResult.pValue,
                    testNote: `Z=${testResult.zScore.toFixed(2)}, p=${testResult.pValue.toFixed(3)}`
                });
            });
            
            // Factors
            const allFactorIds = new Set();
            allLaggedDays.forEach(d => d.factors.forEach(id => allFactorIds.add(id)));
            
            allFactorIds.forEach(factorId => {
                const x1 = allLaggedDays.filter(d => d.precedesBadMood && d.factors.includes(factorId)).length;
                const x2 = allLaggedDays.filter(d => d.factors.includes(factorId)).length;
                
                if (x2 < 2) return;
                
                const p1 = x1 / n1;
                const p2 = x2 / n2;
                const diff = (p1 - p2) * 100;
                
                if (Math.abs(diff) < 1) return;
                
                const testResult = twoProportionZTest(x1, n1, x2, n2, alpha);
                const option = userSettings.factors.options.find(o => o.id === factorId);
                
                differences.push({
                    label: option ? `${option.emoji} ${option.label}` : factorId,
                    diff: diff,
                    badAvg: p1 * 100,
                    normalAvg: p2 * 100,
                    type: 'rate',
                    unit: '%',
                    significant: testResult.significant,
                    zScore: testResult.zScore,
                    pValue: testResult.pValue,
                    testNote: `Z=${testResult.zScore.toFixed(2)}, p=${testResult.pValue.toFixed(3)}`
                });
            });
            
            // Social
            const allSocialIds = new Set();
            allLaggedDays.forEach(d => d.social.forEach(id => allSocialIds.add(id)));
            
            allSocialIds.forEach(socialId => {
                const x1 = allLaggedDays.filter(d => d.precedesBadMood && d.social.includes(socialId)).length;
                const x2 = allLaggedDays.filter(d => d.social.includes(socialId)).length;
                
                if (x2 < 2) return;
                
                const p1 = x1 / n1;
                const p2 = x2 / n2;
                const diff = (p1 - p2) * 100;
                
                if (Math.abs(diff) < 1) return;
                
                const testResult = twoProportionZTest(x1, n1, x2, n2, alpha);
                const option = userSettings.people.options.find(o => o.id === socialId);
                
                differences.push({
                    label: option ? `${option.emoji} ${option.label}` : socialId,
                    diff: diff,
                    badAvg: p1 * 100,
                    normalAvg: p2 * 100,
                    type: 'rate',
                    unit: '%',
                    significant: testResult.significant,
                    zScore: testResult.zScore,
                    pValue: testResult.pValue,
                    testNote: `Z=${testResult.zScore.toFixed(2)}, p=${testResult.pValue.toFixed(3)}`
                });
            });
            
            // Weather
            const allWeatherIds = new Set();
            allLaggedDays.forEach(d => d.weather.forEach(id => allWeatherIds.add(id)));
            
            allWeatherIds.forEach(weatherId => {
                const x1 = allLaggedDays.filter(d => d.precedesBadMood && d.weather.includes(weatherId)).length;
                const x2 = allLaggedDays.filter(d => d.weather.includes(weatherId)).length;
                
                if (x2 < 2) return;
                
                const p1 = x1 / n1;
                const p2 = x2 / n2;
                const diff = (p1 - p2) * 100;
                
                if (Math.abs(diff) < 1) return;
                
                const testResult = twoProportionZTest(x1, n1, x2, n2, alpha);
                const option = userSettings.weather.options.find(o => o.id === weatherId);
                
                differences.push({
                    label: option ? `${option.emoji} ${option.label}` : weatherId,
                    diff: diff,
                    badAvg: p1 * 100,
                    normalAvg: p2 * 100,
                    type: 'rate',
                    unit: '%',
                    significant: testResult.significant,
                    zScore: testResult.zScore,
                    pValue: testResult.pValue,
                    testNote: `Z=${testResult.zScore.toFixed(2)}, p=${testResult.pValue.toFixed(3)}`
                });
            });
            
            // Sort by absolute difference (most impactful first)
            differences.sort((a, b) => Math.abs(b.diff) - Math.abs(a.diff));
            
            // Show all differences (no limit)
            const topDifferences = differences;
            
            if (topDifferences.length === 0) {
                const ctx = badMoodPredictorsCanvas.getContext('2d');
                ctx.clearRect(0, 0, badMoodPredictorsCanvas.width, badMoodPredictorsCanvas.height);
                ctx.font = '14px Nunito';
                ctx.fillStyle = '#8A8A8A';
                ctx.textAlign = 'center';
                ctx.fillText('Not enough data yet. Keep tracking to see patterns!', badMoodPredictorsCanvas.width / 2, badMoodPredictorsCanvas.height / 2);
                return;
            }
            
            // Dynamically set container height based on number of items
            // Each bar needs approximately 28px height
            const barHeight = 28;
            const minHeight = 350;
            const calculatedHeight = Math.max(minHeight, topDifferences.length * barHeight + 80);
            const container = document.getElementById('badMoodPredictorsContainer');
            if (container) {
                container.style.height = calculatedHeight + 'px';
            }
            
            // Prepare chart data
            const labels = topDifferences.map(d => d.label);
            const data = topDifferences.map(d => d.diff);
            const colors = topDifferences.map(d => {
                const baseColor = d.diff > 0 ? 'rgba(239, 68, 68' : 'rgba(34, 197, 94'; // Red or Green
                const opacity = useSignificance ? (d.significant ? ', 1)' : ', 0.3)') : ', 1)';
                return baseColor + opacity;
            });
            
            // Create chart
            if (charts.badMoodPredictors) {
                charts.badMoodPredictors.destroy();
            }
            
            const ctx = badMoodPredictorsCanvas.getContext('2d');
            charts.badMoodPredictors = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Difference from Normal',
                        data: data,
                        backgroundColor: colors,
                        borderRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Difference from Normal (before bad mood vs. all days)',
                                font: { size: 11 }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value > 0 ? `+${value.toFixed(1)}` : value.toFixed(1);
                                }
                            }
                        },
                        y: {
                            ticks: {
                                autoSkip: false,
                                font: { size: 11 }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const item = topDifferences[context.dataIndex];
                                    const diffStr = item.diff > 0 ? `+${item.diff.toFixed(2)}` : item.diff.toFixed(2);
                                    const lines = [];
                                    
                                    if (item.type === 'rate') {
                                        lines.push(`Difference: ${diffStr}%`);
                                        lines.push(`Before bad mood: ${item.badAvg.toFixed(1)}%`);
                                        lines.push(`All days: ${item.normalAvg.toFixed(1)}%`);
                                        if (item.zScore !== undefined) {
                                            lines.push(`Z-score: ${item.zScore.toFixed(2)}`);
                                            lines.push(`p-value: ${item.pValue.toFixed(4)}`);
                                            lines.push(item.significant ? 'âœ“ Significant' : 'â—‹ Not significant');
                                        }
                                    } else {
                                        lines.push(`Difference: ${diffStr}${item.unit}`);
                                        lines.push(`Before bad mood: ${item.badAvg.toFixed(2)}${item.unit}`);
                                        lines.push(`All days: ${item.normalAvg.toFixed(2)}${item.unit}`);
                                        lines.push(item.significant ? 'âœ“ Meaningful' : 'â—‹ Small effect');
                                    }
                                    
                                    return lines;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Populate dropdown with all recorded instances (OLD - now unused in Analytics)
        function populateRecordSelector(allMoodData) {
            const selector = document.getElementById('recordSelector');
            const records = new Map(); // Use Map to track unique records with their type
            
            // Collect all activities
            allMoodData.forEach(d => {
                if (d.activities && d.activities.length > 0) {
                    d.activities.forEach(actId => {
                        const option = userSettings.activities.options.find(o => o.id === actId);
                        if (option) {
                            const key = `activity_${actId}`;
                            if (!records.has(key)) {
                                records.set(key, {
                                    type: 'activity',
                                    id: actId,
                                    label: `${option.emoji} ${option.label}`,
                                    moods: []
                                });
                            }
                            records.get(key).moods.push(d.mood);
                        }
                    });
                }
            });
            
            // Collect all weather
            allMoodData.forEach(d => {
                if (d.weather) {
                    const weatherArray = Array.isArray(d.weather) ? d.weather : [d.weather];
                    weatherArray.forEach(weatherId => {
                        const option = userSettings.weather.options.find(o => o.id === weatherId);
                        if (option) {
                            const key = `weather_${weatherId}`;
                            if (!records.has(key)) {
                                records.set(key, {
                                    type: 'weather',
                                    id: weatherId,
                                    label: `${option.emoji} ${option.label}`,
                                    moods: []
                                });
                            }
                            records.get(key).moods.push(d.mood);
                        }
                    });
                }
            });
            
            // Collect all social/people
            allMoodData.forEach(d => {
                if (d.social && d.social.length > 0) {
                    d.social.forEach(socialId => {
                        const option = userSettings.people.options.find(o => o.id === socialId);
                        if (option) {
                            const key = `social_${socialId}`;
                            if (!records.has(key)) {
                                records.set(key, {
                                    type: 'social',
                                    id: socialId,
                                    label: `${option.emoji} ${option.label}`,
                                    moods: []
                                });
                            }
                            records.get(key).moods.push(d.mood);
                        }
                    });
                }
            });
            
            // Collect all factors
            allMoodData.forEach(d => {
                if (d.factors && d.factors.length > 0) {
                    d.factors.forEach(factorId => {
                        const option = userSettings.factors.options.find(o => o.id === factorId);
                        if (option) {
                            const key = `factor_${factorId}`;
                            if (!records.has(key)) {
                                records.set(key, {
                                    type: 'factor',
                                    id: factorId,
                                    label: `${option.emoji} ${option.label}`,
                                    moods: []
                                });
                            }
                            records.get(key).moods.push(d.mood);
                        }
                    });
                }
            });
            
            // Clear and populate selector
            selector.innerHTML = '<option value="">Select a record...</option>';
            
            // Sort by type and label
            const sortedRecords = Array.from(records.entries()).sort((a, b) => {
                if (a[1].type !== b[1].type) return a[1].type.localeCompare(b[1].type);
                return a[1].label.localeCompare(b[1].label);
            });
            
            let currentType = null;
            sortedRecords.forEach(([key, record]) => {
                // Add group header if type changed
                if (record.type !== currentType) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = record.type.charAt(0).toUpperCase() + record.type.slice(1);
                    selector.appendChild(optgroup);
                    currentType = record.type;
                }
                
                const option = document.createElement('option');
                option.value = key;
                option.textContent = `${record.label} (${record.moods.length})`;
                selector.lastChild.appendChild(option);
            });
            
            // Store records for later use
            window.recordsData = records;
            
            // Add event listener
            selector.addEventListener('change', () => {});  // Old event listener - unused
        }
        
        // Record Tab Charts
        let recordCharts = {};
        
        async function loadRecordData(startDate, endDate) {
            const allData = await getAllMoodData(startDate, endDate);
            window.currentRecordData = allData;  // Store for when selection changes
            populateRecordSelection(allData);
            renderRecordCharts(allData);
        }
        
        function renderRecordCharts(allMoodData) {
            // Destroy existing charts
            Object.values(recordCharts).forEach(chart => chart.destroy());
            recordCharts = {};
            
            const selectedRecord = document.getElementById('recordSelection').value;
            
            if (!selectedRecord) {
                // Show placeholder
                document.getElementById('recordChartsContainer').style.display = 'none';
                document.getElementById('recordPlaceholder').style.display = 'block';
                return;
            }
            
            // Hide placeholder, show charts
            document.getElementById('recordPlaceholder').style.display = 'none';
            document.getElementById('recordChartsContainer').style.display = 'block';
            
            // Get significance level
            const alphaValue = document.getElementById('recordSignificanceLevel').value;
            const useSignificance = alphaValue !== 'none';
            const alpha = useSignificance ? parseFloat(alphaValue) : 0.05;
            
            // Parse selected record
            const [type, id] = selectedRecord.split('_');
            
            // Get all records data
            const allRecords = collectAllRecords(allMoodData);
            const selectedRecordData = allRecords.find(r => r.key === selectedRecord);
            
            if (!selectedRecordData) return;
            
            // 1. Mood Distribution
            renderMoodDistribution(selectedRecordData);
            
            // 2. Lift Analysis
            renderLiftAnalysis(selectedRecordData, allRecords, allMoodData, useSignificance, alpha);
            
            // 3. Correlation Analysis
            renderCorrelationAnalysis(selectedRecordData, allRecords, allMoodData, useSignificance, alpha);
        }
        
        function collectAllRecords(allMoodData) {
            const records = new Map();
            
            allMoodData.forEach(d => {
                // Activities
                if (d.activities && Array.isArray(d.activities)) {
                    d.activities.forEach(actId => {
                        const key = `activity_${actId}`;
                        if (!records.has(key)) {
                            const option = userSettings.activities.options.find(o => o.id === actId);
                            records.set(key, {
                                key,
                                type: 'activity',
                                id: actId,
                                label: option ? `${option.emoji} ${option.label}` : actId,
                                entries: []
                            });
                        }
                        records.get(key).entries.push(d);
                    });
                }
                
                // Weather
                const weatherArray = Array.isArray(d.weather) ? d.weather : (d.weather ? [d.weather] : []);
                weatherArray.forEach(wId => {
                    const key = `weather_${wId}`;
                    if (!records.has(key)) {
                        const option = userSettings.weather.options.find(o => o.id === wId);
                        records.set(key, {
                            key,
                            type: 'weather',
                            id: wId,
                            label: option ? `${option.emoji} ${option.label}` : wId,
                            entries: []
                        });
                    }
                    records.get(key).entries.push(d);
                });
                
                // Social
                if (d.social && Array.isArray(d.social)) {
                    d.social.forEach(sId => {
                        const key = `social_${sId}`;
                        if (!records.has(key)) {
                            const option = userSettings.people.options.find(o => o.id === sId);
                            records.set(key, {
                                key,
                                type: 'social',
                                id: sId,
                                label: option ? `${option.emoji} ${option.label}` : sId,
                                entries: []
                            });
                        }
                        records.get(key).entries.push(d);
                    });
                }
                
                // Factors
                if (d.factors && Array.isArray(d.factors)) {
                    d.factors.forEach(fId => {
                        const key = `factor_${fId}`;
                        if (!records.has(key)) {
                            const option = userSettings.factors.options.find(o => o.id === fId);
                            records.set(key, {
                                key,
                                type: 'factor',
                                id: fId,
                                label: option ? `${option.emoji} ${option.label}` : fId,
                                entries: []
                            });
                        }
                        records.get(key).entries.push(d);
                    });
                }
            });
            
            return Array.from(records.values()).filter(r => r.entries.length > 0);
        }
        
        function renderMoodDistribution(record) {
            const distribution = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
            record.entries.forEach(entry => {
                distribution[entry.mood] = (distribution[entry.mood] || 0) + 1;
            });
            
            const total = record.entries.length;
            
            const ctx = document.getElementById('recordMoodDistChart').getContext('2d');
            recordCharts.moodDist = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Rough', 'Bad', 'Okay', 'Good', 'Great'],
                    datasets: [{
                        label: 'Count',
                        data: [distribution[1], distribution[2], distribution[3], distribution[4], distribution[5]],
                        backgroundColor: ['#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e'],
                        borderRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { stepSize: 1 },
                            title: { display: true, text: 'Count' }
                        },
                        x: {
                            title: { display: true, text: 'Mood' }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: `${record.label} - Total: ${record.entries.length} entries`,
                            font: { size: 14 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const count = context.parsed.y;
                                    const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : 0;
                                    return `Count: ${count} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderLiftAnalysis(selectedRecord, allRecords, allMoodData, useSignificance, alpha) {
            const totalEntries = allMoodData.length;
            const pA = selectedRecord.entries.length / totalEntries;
            
            // Calculate lift for each other record
            const liftData = [];
            
            allRecords.forEach(otherRecord => {
                if (otherRecord.key === selectedRecord.key) return;
                
                const pB = otherRecord.entries.length / totalEntries;
                
                // Count co-occurrences
                const coOccurrences = selectedRecord.entries.filter(entryA => 
                    otherRecord.entries.some(entryB => entryB.date === entryA.date)
                ).length;
                
                const pAB = coOccurrences / totalEntries;
                const lift = pAB / (pA * pB);
                
                // Chi-square test
                const observed = [
                    [coOccurrences, selectedRecord.entries.length - coOccurrences],
                    [otherRecord.entries.length - coOccurrences, totalEntries - selectedRecord.entries.length - otherRecord.entries.length + coOccurrences]
                ];
                
                const chiSquare = calculateChiSquare(observed);
                const isSignificant = useSignificance ? chiSquare.significant(alpha) : true;
                
                liftData.push({
                    label: otherRecord.label,
                    lift: lift,
                    significant: isSignificant,
                    coOccurrences: coOccurrences
                });
            });
            
            // Sort by lift value (large to small)
            liftData.sort((a, b) => b.lift - a.lift);
            
            // Show all records (not just top 15)
            const topLifts = liftData;
            
            // Dynamically set container height based on number of items
            const barHeight = 28;
            const minHeight = 350;
            const calculatedHeight = Math.max(minHeight, topLifts.length * barHeight + 80);
            const container = document.getElementById('liftChartContainer');
            if (container) {
                container.style.height = calculatedHeight + 'px';
            }
            
            const ctx = document.getElementById('recordLiftChart').getContext('2d');
            recordCharts.lift = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: topLifts.map(d => d.label),
                    datasets: [{
                        label: 'Lift',
                        data: topLifts.map(d => d.lift),
                        backgroundColor: topLifts.map(d => {
                            const opacity = useSignificance ? (d.significant ? 1.0 : 0.3) : 1.0;
                            if (d.lift > 1.2) return `rgba(34, 197, 94, ${opacity})`; // Green - positive
                            if (d.lift < 0.8) return `rgba(239, 68, 68, ${opacity})`; // Red - negative
                            return `rgba(156, 163, 175, ${opacity})`; // Gray - neutral
                        }),
                        borderRadius: 6
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { 
                                display: true, 
                                text: 'Lift Value (1 = random chance)',
                                font: { size: 11 }
                            },
                            grid: {
                                color: (context) => context.tick.value === 1 ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.1)'
                            }
                        },
                        y: {
                            ticks: {
                                autoSkip: false,
                                font: { size: 11 }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const data = topLifts[context.dataIndex];
                                    const lines = [];
                                    lines.push(`Lift: ${data.lift.toFixed(2)}`);
                                    lines.push(`Co-occurrences: ${data.coOccurrences}`);
                                    if (useSignificance) {
                                        lines.push(data.significant ? 'âœ“ Significant' : 'â—‹ Not significant');
                                    }
                                    return lines;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function renderCorrelationAnalysis(selectedRecord, allRecords, allMoodData, useSignificance, alpha) {
            // Calculate phi coefficient between selected record and other records
            const correlationData = [];
            
            allRecords.forEach(otherRecord => {
                if (otherRecord.key === selectedRecord.key) return;
                
                // Count co-occurrences for 2x2 contingency table
                const coOccurrences = selectedRecord.entries.filter(entryA => 
                    otherRecord.entries.some(entryB => entryB.date === entryA.date)
                ).length;
                
                const totalEntries = allMoodData.length;
                const n11 = coOccurrences; // Both present
                const n10 = selectedRecord.entries.length - coOccurrences; // Only selected present
                const n01 = otherRecord.entries.length - coOccurrences; // Only other present
                const n00 = totalEntries - n11 - n10 - n01; // Neither present
                
                // Calculate phi coefficient
                const phi = calculatePhiCoefficient(n11, n10, n01, n00);
                
                // Chi-square test
                const observed = [[n11, n10], [n01, n00]];
                const chiSquare = calculateChiSquare(observed);
                const isSignificant = useSignificance ? chiSquare.significant(alpha) : true;
                
                if (!isNaN(phi)) {
                    correlationData.push({
                        label: otherRecord.label,
                        correlation: phi,
                        significant: isSignificant
                    });
                }
            });
            
            // Sort by correlation value (large to small)
            correlationData.sort((a, b) => b.correlation - a.correlation);
            
            // Show all records (not just top 15)
            const topCorrelations = correlationData;
            
            // Dynamically set container height based on number of items
            const barHeight = 28;
            const minHeight = 350;
            const calculatedHeight = Math.max(minHeight, topCorrelations.length * barHeight + 80);
            const container = document.getElementById('correlationChartContainer');
            if (container) {
                container.style.height = calculatedHeight + 'px';
            }
            
            const ctx = document.getElementById('recordCorrelationChart').getContext('2d');
            recordCharts.correlation = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: topCorrelations.map(d => d.label),
                    datasets: [{
                        label: 'Phi Coefficient',
                        data: topCorrelations.map(d => d.correlation),
                        backgroundColor: topCorrelations.map(d => {
                            const opacity = useSignificance ? (d.significant ? 1.0 : 0.3) : 1.0;
                            // Gray only for -0.10 to 0.10
                            if (d.correlation > 0.10) return `rgba(34, 197, 94, ${opacity})`; // Green - positive
                            if (d.correlation < -0.10) return `rgba(239, 68, 68, ${opacity})`; // Red - negative
                            return `rgba(156, 163, 175, ${opacity})`; // Gray - neutral
                        }),
                        borderRadius: 6
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            min: -1,
                            max: 1,
                            title: { 
                                display: true, 
                                text: 'Correlation (Ï† coefficient)',
                                font: { size: 11 }
                            },
                            grid: {
                                color: (context) => context.tick.value === 0 ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.1)'
                            }
                        },
                        y: {
                            ticks: {
                                autoSkip: false,
                                font: { size: 11 }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const data = topCorrelations[context.dataIndex];
                                    const lines = [];
                                    lines.push(`Correlation: ${data.correlation.toFixed(3)}`);
                                    if (useSignificance) {
                                        lines.push(data.significant ? 'âœ“ Significant' : 'â—‹ Not significant');
                                    }
                                    return lines;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function calculatePhiCoefficient(n11, n10, n01, n00) {
            // Phi coefficient for 2x2 contingency table
            // Ï† = (n11*n00 - n10*n01) / sqrt((n11+n10)(n01+n00)(n11+n01)(n10+n00))
            
            const numerator = n11 * n00 - n10 * n01;
            const denominator = Math.sqrt((n11 + n10) * (n01 + n00) * (n11 + n01) * (n10 + n00));
            
            if (denominator === 0) return 0;
            return numerator / denominator;
        }
        
        function calculatePearsonCorrelation(x, y) {
            const n = x.length;
            if (n === 0) return 0;
            
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
            const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            
            return denominator === 0 ? 0 : numerator / denominator;
        }
        
        function calculateChiSquare(observed) {
            // observed is 2x2 contingency table: [[a, b], [c, d]]
            const a = observed[0][0];
            const b = observed[0][1];
            const c = observed[1][0];
            const d = observed[1][1];
            
            const n = a + b + c + d;
            
            // Expected frequencies
            const expected = [
                [(a + b) * (a + c) / n, (a + b) * (b + d) / n],
                [(c + d) * (a + c) / n, (c + d) * (b + d) / n]
            ];
            
            // Chi-square statistic
            let chiSq = 0;
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 2; j++) {
                    if (expected[i][j] > 0) {
                        chiSq += Math.pow(observed[i][j] - expected[i][j], 2) / expected[i][j];
                    }
                }
            }
            
            // Degrees of freedom = (rows - 1) * (cols - 1) = 1
            const df = 1;
            
            return {
                value: chiSq,
                df: df,
                significant: function(alpha) {
                    // Critical values for df=1
                    const criticalValues = {
                        0.05: 3.841,  // p < 0.05
                        0.1: 2.706,   // p < 0.1
                        0.2: 1.642    // p < 0.2
                    };
                    return chiSq > (criticalValues[alpha] || criticalValues[0.05]);
                }
            };
        }
        
        function populateRecordSelection(allMoodData) {
            const selector = document.getElementById('recordSelection');
            const currentSelection = selector.value;  // Preserve current selection
            const allRecords = collectAllRecords(allMoodData);
            
            // Clear existing options (except first)
            selector.innerHTML = '<option value="">Select a record...</option>';
            
            // Group by type
            const groups = {
                activity: [],
                weather: [],
                social: [],
                factor: []
            };
            
            allRecords.forEach(record => {
                groups[record.type].push(record);
            });
            
            // Add optgroups
            const typeLabels = {
                activity: 'Activity',
                weather: 'Weather',
                social: 'Social',
                factor: 'Factor'
            };
            
            let firstRecordKey = null;
            
            ['activity', 'weather', 'social', 'factor'].forEach(type => {
                if (groups[type].length > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = typeLabels[type];
                    
                    groups[type].forEach(record => {
                        const option = document.createElement('option');
                        option.value = record.key;
                        option.textContent = `${record.label} (${record.entries.length})`;
                        optgroup.appendChild(option);
                        
                        // Store first record
                        if (!firstRecordKey) {
                            firstRecordKey = record.key;
                        }
                    });
                    
                    selector.appendChild(optgroup);
                }
            });
            
            // Restore previous selection if it still exists, otherwise use first
            if (currentSelection && allRecords.some(r => r.key === currentSelection)) {
                selector.value = currentSelection;
            } else if (firstRecordKey) {
                selector.value = firstRecordKey;
            }
        }

        // Tab Navigation
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabId = btn.dataset.tab;
                
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                btn.classList.add('active');
                document.getElementById(tabId + 'Tab').classList.add('active');

                if (tabId === 'analytics') {
                    loadAllMoodData(startDateInput.value, endDateInput.value);
                } else if (tabId === 'sleep') {
                    const sleepStartDate = document.getElementById('sleepStartDate').value;
                    const sleepEndDate = document.getElementById('sleepEndDate').value;
                    loadSleepData(sleepStartDate, sleepEndDate);
                } else if (tabId === 'record') {
                    const recordStartDate = document.getElementById('recordStartDate').value;
                    const recordEndDate = document.getElementById('recordEndDate').value;
                    loadRecordData(recordStartDate, recordEndDate);
                } else if (tabId === 'settings') {
                    renderAccountInfo();
                    renderCustomization();
                }
            });
        });

        // Event Listeners
        prevMonthBtn.addEventListener('click', async () => {
            currentDate.setMonth(currentDate.getMonth() - 1);
            await loadMoodData(currentDate.getFullYear(), currentDate.getMonth());
        });

        nextMonthBtn.addEventListener('click', async () => {
            currentDate.setMonth(currentDate.getMonth() + 1);
            await loadMoodData(currentDate.getFullYear(), currentDate.getMonth());
        });

        cancelBtn.addEventListener('click', closeModal);
        saveBtn.addEventListener('click', saveMood);

        applyDateRangeBtn.addEventListener('click', () => {
            loadAllMoodData(startDateInput.value, endDateInput.value);
        });

        // Record tab event listeners
        const applyRecordRangeBtn = document.getElementById('applyRecordRange');
        const recordStartDateInput = document.getElementById('recordStartDate');
        const recordEndDateInput = document.getElementById('recordEndDate');
        const recordSelection = document.getElementById('recordSelection');
        
        applyRecordRangeBtn.addEventListener('click', () => {
            loadRecordData(recordStartDateInput.value, recordEndDateInput.value);
        });
        
        // recordSelection change removed - only render on Apply click

        // Export data to Excel
        const exportDataBtn = document.getElementById('exportDataBtn');
        exportDataBtn.addEventListener('click', async () => {
            try {
                showToast('ðŸ“Š Preparing export...', false);
                
                // Get all mood data
                const startDate = startDateInput.value;
                const endDate = endDateInput.value;
                const allData = await getAllMoodData(startDate, endDate);
                
                if (allData.length === 0) {
                    showToast('âš ï¸ No data to export', true);
                    return;
                }
                
                // Sort by date
                allData.sort((a, b) => new Date(a.date) - new Date(b.date));
                
                // Convert to export format
                const exportData = allData.map(entry => {
                    const moodLabels = {1: 'Rough', 2: 'Meh', 3: 'Okay', 4: 'Good', 5: 'Great'};
                    
                    // Get labels for IDs
                    const getLabels = (ids, category) => {
                        if (!ids || ids.length === 0) return '';
                        return ids.map(id => {
                            const option = userSettings[category].options.find(o => o.id === id);
                            return option ? option.label : id;
                        }).join(', ');
                    };
                    
                    const getSingleLabel = (id, category) => {
                        if (!id) return '';
                        const option = userSettings[category].options.find(o => o.id === id);
                        return option ? option.label : id;
                    };
                    
                    return {
                        'Date': entry.date,
                        'Mood': moodLabels[entry.mood] || entry.mood,
                        'Mood Rating': entry.mood,
                        'Activities': getLabels(entry.activities || [], 'activities'),
                        'Social': getLabels(entry.social || [], 'people'),
                        'Weather': getLabels(Array.isArray(entry.weather) ? entry.weather : (entry.weather ? [entry.weather] : []), 'weather'),
                        'Factors': getLabels(entry.factors || [], 'factors'),
                        'Sleep Quality': getSingleLabel(entry.sleep, 'sleep'),
                        'Sleep Time': entry.sleepTime || '',
                        'Wake Time': entry.wakeTime || '',
                        'Sleep Duration (hours)': entry.sleepDuration ? (entry.sleepDuration / 60).toFixed(1) : '',
                        'Note': entry.note || ''
                    };
                });
                
                // Load SheetJS library
                if (typeof XLSX === 'undefined') {
                    const script = document.createElement('script');
                    script.src = 'https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js';
                    document.head.appendChild(script);
                    await new Promise(resolve => script.onload = resolve);
                }
                
                // Create workbook
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.json_to_sheet(exportData);
                
                // Set column widths
                ws['!cols'] = [
                    {wch: 12}, // Date
                    {wch: 10}, // Mood
                    {wch: 12}, // Mood Rating
                    {wch: 25}, // Activities
                    {wch: 20}, // Social
                    {wch: 12}, // Weather
                    {wch: 20}, // Factors
                    {wch: 15}, // Sleep Quality
                    {wch: 12}, // Sleep Time
                    {wch: 12}, // Wake Time
                    {wch: 20}, // Sleep Duration
                    {wch: 40}  // Note
                ];
                
                XLSX.utils.book_append_sheet(wb, ws, 'Mood Data');
                
                // Generate filename with date range
                const filename = `mood-tracker-${startDate}_to_${endDate}.xlsx`;
                
                // Download file
                XLSX.writeFile(wb, filename);
                
                showToast(`âœ… Exported ${allData.length} entries!`);
            } catch (error) {
                console.error('Export error:', error);
                showToast('âŒ Export failed. Please try again.', true);
            }
        });

        // Import data from Excel/CSV
        const importDataBtn = document.getElementById('importDataBtn');
        const importDataInput = document.getElementById('importDataInput');
        const importStatus = document.getElementById('importStatus');
        const importStatusText = document.getElementById('importStatusText');

        importDataBtn.addEventListener('click', () => {
            if (!currentUser) {
                showToast('âš ï¸ Please sign in to import data', true);
                return;
            }
            importDataInput.click();
        });

        importDataInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                importStatus.style.display = 'block';
                importStatusText.textContent = 'Reading file...';

                // Load SheetJS library if not already loaded
                if (typeof XLSX === 'undefined') {
                    const script = document.createElement('script');
                    script.src = 'https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js';
                    document.head.appendChild(script);
                    await new Promise(resolve => script.onload = resolve);
                }

                // Read the file
                const data = await file.arrayBuffer();
                const workbook = XLSX.read(data, { type: 'array' });
                
                // Get the first sheet
                const sheetName = workbook.SheetNames[0];
                const sheet = workbook.Sheets[sheetName];
                
                // Convert to JSON
                const jsonData = XLSX.utils.sheet_to_json(sheet);
                
                if (jsonData.length === 0) {
                    showToast('âš ï¸ No data found in file', true);
                    importStatus.style.display = 'none';
                    importDataInput.value = '';
                    return;
                }

                importStatusText.textContent = `Processing ${jsonData.length} entries...`;

                // Random emoji pool for auto-created options
                const randomEmojis = [
                    'ðŸŽ¯', 'ðŸŽ¨', 'ðŸŽ­', 'ðŸŽª', 'ðŸŽ¸', 'ðŸŽº', 'ðŸŽ»', 'ðŸ¥', 'ðŸŽ¬', 'ðŸŽ¤',
                    'ðŸƒ', 'ðŸš´', 'ðŸŠ', 'â›·ï¸', 'ðŸ„', 'ðŸ§˜', 'ðŸ¤¸', 'ðŸ‹ï¸', 'ðŸ¤¾', 'âš½',
                    'ðŸŒŸ', 'âœ¨', 'ðŸ’«', 'ðŸŒˆ', 'ðŸ”¥', 'ðŸ’Ž', 'ðŸŽ', 'ðŸ†', 'ðŸŽ–ï¸', 'ðŸ¥‡',
                    'ðŸ“š', 'ðŸ“', 'âœï¸', 'ðŸ–Šï¸', 'ðŸ“–', 'ðŸŽ“', 'ðŸ’¡', 'ðŸ”¬', 'ðŸ”­', 'ðŸ§ª',
                    'ðŸŽ', 'ðŸ•', 'ðŸ”', 'ðŸ¿', 'ðŸŽ‚', 'ðŸ©', 'ðŸª', 'â˜•', 'ðŸµ', 'ðŸ¥¤',
                    'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ»', 'ðŸŒ¼', 'ðŸŒ·', 'ðŸŒ¹', 'ðŸ€', 'ðŸŒ¿', 'ðŸŒ´', 'ðŸŒ³',
                    'ðŸ¶', 'ðŸ±', 'ðŸ°', 'ðŸ¦Š', 'ðŸ»', 'ðŸ¼', 'ðŸ¦', 'ðŸ¯', 'ðŸ¦„', 'ðŸ',
                    'â¤ï¸', 'ðŸ§¡', 'ðŸ’›', 'ðŸ’š', 'ðŸ’™', 'ðŸ’œ', 'ðŸ–¤', 'ðŸ¤', 'ðŸ’–', 'ðŸ’',
                    'â­', 'ðŸŒ™', 'â˜€ï¸', 'ðŸŒ¤ï¸', 'â›…', 'ðŸŒ§ï¸', 'â„ï¸', 'ðŸŒŠ', 'ðŸ”ï¸', 'ðŸï¸',
                    'ðŸŽ®', 'ðŸŽ²', 'ðŸ§©', 'â™Ÿï¸', 'ðŸƒ', 'ðŸŽ´', 'ðŸ€„', 'ðŸŽ°', 'ðŸŽ³', 'ðŸŽ¯'
                ];
                
                // Track newly created options to save settings once at the end
                let settingsModified = false;
                
                // Helper function to get a random emoji
                const getRandomEmoji = () => {
                    return randomEmojis[Math.floor(Math.random() * randomEmojis.length)];
                };

                // Helper function to find option ID by label, or create new option if not found
                const findOrCreateOptionId = (label, category) => {
                    if (!label || label.trim() === '') return null;
                    
                    const trimmedLabel = label.trim();
                    
                    // First, try to find existing option
                    const existingOption = userSettings[category].options.find(
                        o => o.label.toLowerCase() === trimmedLabel.toLowerCase()
                    );
                    
                    if (existingOption) {
                        return existingOption.id;
                    }
                    
                    // Option doesn't exist - create a new one
                    const newId = trimmedLabel.toLowerCase().replace(/\s+/g, '_') + '_imported_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                    const newOption = {
                        id: newId,
                        emoji: getRandomEmoji(),
                        label: trimmedLabel,
                        default: false,
                        enabled: true
                    };
                    
                    // Add to userSettings
                    userSettings[category].options.push(newOption);
                    settingsModified = true;
                    
                    console.log(`Created new ${category} option: ${trimmedLabel} with emoji ${newOption.emoji}`);
                    
                    return newId;
                };

                // Helper function to parse comma-separated labels to IDs (creating options as needed)
                const parseLabelsToIds = (labelsString, category) => {
                    if (!labelsString || labelsString.toString().trim() === '') return [];
                    return labelsString.toString().split(',')
                        .map(label => findOrCreateOptionId(label.trim(), category))
                        .filter(id => id !== null);
                };

                // Helper function to parse sleep quality label to ID
                const parseSleepQuality = (label) => {
                    if (!label || label.trim() === '') return null;
                    const sleepLabels = {
                        'poor': 'poor',
                        'okay': 'ok',
                        'ok': 'ok',
                        'good': 'good',
                        'great': 'great'
                    };
                    return sleepLabels[label.trim().toLowerCase()] || null;
                };

                // Helper function to parse mood label to rating
                const parseMoodLabel = (label) => {
                    const moodLabels = {
                        'rough': 1,
                        'meh': 2,
                        'okay': 3,
                        'good': 4,
                        'great': 5
                    };
                    if (typeof label === 'number') return label;
                    return moodLabels[label?.toString().toLowerCase()] || null;
                };

                // Helper to normalize time format (HH:MM)
                const normalizeTime = (timeStr) => {
                    if (!timeStr || timeStr.toString().trim() === '') return null;
                    
                    // Handle Excel time format (decimal number representing fraction of day)
                    if (typeof timeStr === 'number') {
                        const totalMinutes = Math.round(timeStr * 24 * 60);
                        const hours = Math.floor(totalMinutes / 60) % 24;
                        const minutes = totalMinutes % 60;
                        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
                    }
                    
                    const str = timeStr.toString().trim();
                    
                    // Handle HH:MM format
                    const match = str.match(/^(\d{1,2}):(\d{2})$/);
                    if (match) {
                        const hours = parseInt(match[1]);
                        const minutes = parseInt(match[2]);
                        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
                    }
                    
                    // Handle HH:MM AM/PM format
                    const ampmMatch = str.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
                    if (ampmMatch) {
                        let hours = parseInt(ampmMatch[1]);
                        const minutes = parseInt(ampmMatch[2]);
                        const isPM = ampmMatch[3].toUpperCase() === 'PM';
                        if (isPM && hours !== 12) hours += 12;
                        if (!isPM && hours === 12) hours = 0;
                        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
                    }
                    
                    return null;
                };

                // Helper to normalize date format
                const normalizeDate = (dateValue) => {
                    if (!dateValue) return null;
                    
                    // Handle Excel serial date number
                    if (typeof dateValue === 'number') {
                        // Excel dates are days since 1900-01-01 (with a bug for 1900 leap year)
                        const excelEpoch = new Date(1899, 11, 30);
                        const date = new Date(excelEpoch.getTime() + dateValue * 24 * 60 * 60 * 1000);
                        return date.toISOString().split('T')[0];
                    }
                    
                    const str = dateValue.toString().trim();
                    
                    // Try to parse various date formats
                    // YYYY-MM-DD
                    if (/^\d{4}-\d{2}-\d{2}$/.test(str)) {
                        return str;
                    }
                    
                    // MM/DD/YYYY or M/D/YYYY
                    const usMatch = str.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
                    if (usMatch) {
                        const month = String(usMatch[1]).padStart(2, '0');
                        const day = String(usMatch[2]).padStart(2, '0');
                        return `${usMatch[3]}-${month}-${day}`;
                    }
                    
                    // DD/MM/YYYY
                    const euMatch = str.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
                    if (euMatch) {
                        // Assume US format for consistency
                        const month = String(euMatch[1]).padStart(2, '0');
                        const day = String(euMatch[2]).padStart(2, '0');
                        return `${euMatch[3]}-${month}-${day}`;
                    }
                    
                    // Try native Date parsing
                    const parsed = new Date(str);
                    if (!isNaN(parsed.getTime())) {
                        return parsed.toISOString().split('T')[0];
                    }
                    
                    return null;
                };

                // Process and save each entry
                let successCount = 0;
                let errorCount = 0;

                for (let i = 0; i < jsonData.length; i++) {
                    const row = jsonData[i];
                    
                    // Update progress
                    importStatusText.textContent = `Importing ${i + 1} of ${jsonData.length}...`;

                    try {
                        // Parse date
                        const dateKey = normalizeDate(row['Date'] || row['date']);
                        if (!dateKey) {
                            console.warn('Skipping row with invalid date:', row);
                            errorCount++;
                            continue;
                        }

                        // Parse mood
                        let mood = row['Mood Rating'] || row['mood rating'] || row['Mood'] || row['mood'];
                        if (typeof mood === 'string') {
                            mood = parseMoodLabel(mood);
                        }
                        mood = parseInt(mood);
                        if (isNaN(mood) || mood < 1 || mood > 5) {
                            console.warn('Skipping row with invalid mood:', row);
                            errorCount++;
                            continue;
                        }

                        // Parse activities
                        const activities = parseLabelsToIds(
                            row['Activities'] || row['activities'] || '', 
                            'activities'
                        );

                        // Parse social
                        const social = parseLabelsToIds(
                            row['Social'] || row['social'] || '', 
                            'people'
                        );

                        // Parse weather
                        const weatherLabels = row['Weather'] || row['weather'] || '';
                        const weather = parseLabelsToIds(weatherLabels, 'weather');

                        // Parse factors
                        const factors = parseLabelsToIds(
                            row['Factors'] || row['factors'] || '', 
                            'factors'
                        );

                        // Parse sleep quality
                        const sleep = parseSleepQuality(
                            row['Sleep Quality'] || row['sleep quality'] || ''
                        );

                        // Parse sleep/wake times
                        const sleepTime = normalizeTime(row['Sleep Time'] || row['sleep time'] || '');
                        const wakeTime = normalizeTime(row['Wake Time'] || row['wake time'] || '');

                        // Calculate sleep duration
                        let sleepDuration = null;
                        const durationStr = row['Sleep Duration (hours)'] || row['sleep duration (hours)'] || '';
                        if (durationStr && durationStr.toString().trim() !== '') {
                            const hours = parseFloat(durationStr);
                            if (!isNaN(hours)) {
                                sleepDuration = Math.round(hours * 60); // Convert to minutes
                            }
                        } else if (sleepTime && wakeTime) {
                            // Calculate from times if duration not provided
                            const [sleepHour, sleepMin] = sleepTime.split(':').map(Number);
                            const [wakeHour, wakeMin] = wakeTime.split(':').map(Number);
                            let sleepMinutes = sleepHour * 60 + sleepMin;
                            let wakeMinutes = wakeHour * 60 + wakeMin;
                            if (wakeMinutes <= sleepMinutes) {
                                wakeMinutes += 24 * 60;
                            }
                            sleepDuration = wakeMinutes - sleepMinutes;
                        }

                        // Parse note
                        const note = row['Note'] || row['note'] || '';

                        // Create mood data object
                        const moodData = {
                            mood,
                            social: social.length > 0 ? social : [],
                            weather: weather.length > 0 ? weather : [],
                            activities: activities.length > 0 ? activities : [],
                            factors: factors.length > 0 ? factors : [],
                            sleep,
                            sleepTime,
                            wakeTime,
                            sleepDuration,
                            note: note.toString(),
                            timestamp: new Date().toISOString()
                        };

                        // Save to Firestore and localStorage
                        await saveMoodData(dateKey, moodData);
                        successCount++;
                    } catch (err) {
                        console.error('Error importing row:', row, err);
                        errorCount++;
                    }
                }

                // If new options were created, save the settings
                if (settingsModified) {
                    importStatusText.textContent = 'Saving new options...';
                    await autoSaveSettings();
                    // Refresh the customization UI to show new options
                    renderCustomization();
                }

                importStatus.style.display = 'none';
                importDataInput.value = '';

                // Refresh the calendar and analytics
                await loadMoodData(currentDate.getFullYear(), currentDate.getMonth());
                await setStartDateToFirstRecord();
                
                if (errorCount === 0) {
                    if (settingsModified) {
                        showToast(`âœ… Imported ${successCount} entries with new options created!`);
                    } else {
                        showToast(`âœ… Successfully imported ${successCount} entries!`);
                    }
                } else {
                    showToast(`âœ… Imported ${successCount} entries (${errorCount} skipped)`, errorCount > successCount);
                }
            } catch (error) {
                console.error('Import error:', error);
                importStatus.style.display = 'none';
                importDataInput.value = '';
                showToast('âŒ Import failed. Please check your file format.', true);
            }
        });

        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) closeModal();
        });

        // Mood options (single choice)
        document.querySelectorAll('.mood-option').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.mood-option').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
            });
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeModal();
        });

        // Sleep Analysis Tab
        const sleepStartDateInput = document.getElementById('sleepStartDate');
        const sleepEndDateInput = document.getElementById('sleepEndDate');
        const applySleepDateRangeBtn = document.getElementById('applySleepDateRange');
        let sleepCharts = {};

        async function loadSleepData(startDate, endDate) {
            const allData = await getAllMoodData(startDate, endDate);
            renderSleepCharts(allData);
        }

        function renderSleepCharts(allMoodData) {
            // Destroy existing charts
            Object.values(sleepCharts).forEach(chart => chart?.destroy());
            sleepCharts = {};

            // Get selected significance level
            const alphaValue = document.getElementById('sleepSignificanceLevel').value;
            const useSignificance = alphaValue !== 'none';
            const alpha = useSignificance ? parseFloat(alphaValue) : 0.05;

            // Filter data with sleep information and calculate sleepDuration if missing
            const sleepData = allMoodData.filter(d => d.sleepDuration || (d.sleepTime && d.wakeTime)).map(d => {
                // If sleepDuration is missing but we have times, calculate it
                if (!d.sleepDuration && d.sleepTime && d.wakeTime) {
                    const [sh, sm] = d.sleepTime.split(':').map(Number);
                    const [wh, wm] = d.wakeTime.split(':').map(Number);
                    let sleepMinutes = sh * 60 + sm;
                    let wakeMinutes = wh * 60 + wm;
                    // Adjust if wake time is on next day
                    if (wakeMinutes < sleepMinutes) {
                        wakeMinutes += 24 * 60;
                    }
                    return { ...d, sleepDuration: wakeMinutes - sleepMinutes };
                }
                return d;
            });
            
            if (sleepData.length === 0) {
                return;
            }

            // Calculate statistics
            const durations = sleepData.filter(d => d.sleepDuration).map(d => d.sleepDuration / 60);
            const avgDuration = durations.length > 0 ? durations.reduce((a, b) => a + b, 0) / durations.length : 0;
            document.getElementById('avgSleepDuration').textContent = avgDuration.toFixed(1);

            // Calculate average sleep and wake times
            const sleepTimes = sleepData.filter(d => d.sleepTime).map(d => {
                const [h, m] = d.sleepTime.split(':').map(Number);
                let time = h + m / 60;
                if (time < 12) time += 24;
                return time;
            });
            if (sleepTimes.length > 0) {
                const avgSleepTime = sleepTimes.reduce((a, b) => a + b, 0) / sleepTimes.length;
                const hour = Math.floor(avgSleepTime % 24);
                const min = Math.round((avgSleepTime % 1) * 60);
                const period = hour >= 12 ? 'PM' : 'AM';
                const dispHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
                document.getElementById('avgSleepTime').textContent = `${dispHour}:${String(min).padStart(2, '0')} ${period}`;
            }

            const wakeTimes = sleepData.filter(d => d.wakeTime).map(d => {
                const [h, m] = d.wakeTime.split(':').map(Number);
                return h + m / 60;
            });
            if (wakeTimes.length > 0) {
                const avgWakeTime = wakeTimes.reduce((a, b) => a + b, 0) / wakeTimes.length;
                const hour = Math.floor(avgWakeTime);
                const min = Math.round((avgWakeTime % 1) * 60);
                const period = hour >= 12 ? 'PM' : 'AM';
                const dispHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
                document.getElementById('avgWakeTime').textContent = `${dispHour}:${String(min).padStart(2, '0')} ${period}`;
            }

            // Calculate sleep consistency
            if (sleepTimes.length > 1) {
                const variance = sleepTimes.reduce((sum, time) => {
                    const diff = time - (sleepTimes.reduce((a, b) => a + b) / sleepTimes.length);
                    return sum + diff * diff;
                }, 0) / sleepTimes.length;
                const stdDev = Math.sqrt(variance);
                const consistency = Math.max(0, 100 - (stdDev * 10));
                
                // Get rating label
                let rating = '';
                if (consistency >= 90) rating = 'ðŸŸ¢ Very Regular';
                else if (consistency >= 70) rating = 'ðŸ”µ Regular';
                else if (consistency >= 50) rating = 'ðŸŸ¡ Moderate';
                else if (consistency >= 30) rating = 'ðŸŸ  Irregular';
                else rating = 'ðŸ”´ Highly Irregular';
                
                document.getElementById('sleepConsistency').textContent = rating;
            }

            // 1. Sleep Schedule Chart
            const scheduleData = sleepData.filter(d => d.sleepTime && d.wakeTime).sort((a, b) => new Date(a.date) - new Date(b.date));
            if (scheduleData.length > 0) {
                const labels = scheduleData.map(d => new Date(d.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
                const sleepTimesChart = scheduleData.map(d => {
                    const [h, m] = d.sleepTime.split(':').map(Number);
                    let time = h + m / 60;
                    if (time < 12) time += 24;
                    return time;
                });
                const wakeTimesChart = scheduleData.map(d => {
                    const [h, m] = d.wakeTime.split(':').map(Number);
                    let time = h + m / 60;
                    const [sh, sm] = d.sleepTime.split(':').map(Number);
                    let stime = sh + sm / 60;
                    if (stime < 12) stime += 24;
                    if (time < 12) time += 24;
                    if (time < stime) time += 24;
                    return time;
                });

                const minSleep = Math.min(...sleepTimesChart);
                const maxWake = Math.max(...wakeTimesChart);
                const yAxisMax = Math.floor(minSleep) - 1;
                const yAxisMin = Math.ceil(maxWake) + 1;

                const ctx = document.getElementById('sleepScheduleChartSleep').getContext('2d');
                sleepCharts.schedule = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Sleep Time',
                            data: sleepTimesChart,
                            borderColor: '#4A5FD9',
                            backgroundColor: 'rgba(107, 203, 119, 0.3)',
                            fill: '+1',
                            pointRadius: 4,
                            borderWidth: 2,
                            tension: 0.3
                        }, {
                            label: 'Wake Time',
                            data: wakeTimesChart,
                            borderColor: '#FFB84D',
                            fill: false,
                            pointRadius: 4,
                            borderWidth: 2,
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { ticks: { maxTicksLimit: 15 } },
                            y: {
                                reverse: true,
                                min: yAxisMin,
                                max: yAxisMax,
                                ticks: {
                                    stepSize: 2,
                                    callback: function(value) {
                                        const hour = value % 24;
                                        const period = hour >= 12 ? 'PM' : 'AM';
                                        const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
                                        return `${displayHour} ${period}`;
                                    }
                                }
                            }
                        },
                        plugins: { 
                            legend: { display: true, position: 'top' },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const value = context.parsed.y;
                                        const hour = value % 24;
                                        const hourInt = Math.floor(hour);
                                        const minutes = Math.round((hour % 1) * 60);
                                        const period = hourInt >= 12 ? 'PM' : 'AM';
                                        const displayHour = hourInt === 0 ? 12 : hourInt > 12 ? hourInt - 12 : hourInt;
                                        return `${context.dataset.label}: ${displayHour}:${String(minutes).padStart(2, '0')} ${period}`;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // Get all moods for significance testing
            const allMoods = sleepData.map(d => d.mood);

            // 2. Sleep Duration Category Chart
            const durationCategoryData = { '<5 hrs': [], '5-7 hrs': [], '7-9 hrs': [], '>9 hrs': [] };
            sleepData.filter(d => d.sleepDuration).forEach(d => {
                const hours = d.sleepDuration / 60;
                if (hours < 5) durationCategoryData['<5 hrs'].push(d.mood);
                else if (hours < 7) durationCategoryData['5-7 hrs'].push(d.mood);
                else if (hours < 9) durationCategoryData['7-9 hrs'].push(d.mood);
                else durationCategoryData['>9 hrs'].push(d.mood);
            });

            const durationLabels = Object.keys(durationCategoryData).filter(k => durationCategoryData[k].length > 0);
            const durationStats = durationLabels.map(k => ({
                label: k,
                avg: durationCategoryData[k].reduce((a, b) => a + b, 0) / durationCategoryData[k].length,
                significant: useSignificance ? testCategorySignificance(durationCategoryData[k], allMoods, alpha) : true
            }));
            const durationAvgs = durationStats.map(s => s.avg);
            const durationColors = ['#FF6B6B', '#FFB84D', '#6BCB77', '#4ECDC4'].map((color, i) => {
                if (!durationStats[i]) return color;
                const alpha_opacity = useSignificance ? (durationStats[i].significant ? 1.0 : 0.3) : 1.0;
                // Convert hex to rgba
                const r = parseInt(color.slice(1,3), 16);
                const g = parseInt(color.slice(3,5), 16);
                const b = parseInt(color.slice(5,7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha_opacity})`;
            });
            
            if (durationLabels.length > 0) {
                const ctx2 = document.getElementById('sleepDurationCategoryChart').getContext('2d');
                sleepCharts.durationCategory = new Chart(ctx2, {
                    type: 'bar',
                    data: {
                        labels: durationLabels,
                        datasets: [{
                            label: 'Avg Mood',
                            data: durationAvgs,
                            backgroundColor: durationColors,
                            borderRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: { y: { min: 0, max: 5, ticks: { stepSize: 1 } } },
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (!useSignificance) return '';
                                        const stat = durationStats[context.dataIndex];
                                        return stat.significant ? `(Significant p<${alpha})` : '(Not significant)';
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // 3. Sleep Time Category Chart
            const sleepTimeCategoryData = { 'Before 10PM': [], '10PM-11PM': [], '11PM-12AM': [], 'After 12AM': [] };
            sleepData.filter(d => d.sleepTime).forEach(d => {
                const [h, m] = d.sleepTime.split(':').map(Number);
                // Categorize based on hour
                if (h < 10) {
                    // 12AM-9AM is "After 12AM" (early morning bedtimes)
                    sleepTimeCategoryData['After 12AM'].push(d.mood);
                } else if (h < 22) {
                    // 10AM-9PM is "Before 10PM" (unusual, but handle it)
                    sleepTimeCategoryData['Before 10PM'].push(d.mood);
                } else if (h === 22) {
                    // 10PM-10:59PM
                    sleepTimeCategoryData['10PM-11PM'].push(d.mood);
                } else if (h === 23) {
                    // 11PM-11:59PM
                    sleepTimeCategoryData['11PM-12AM'].push(d.mood);
                }
            });

            const sleepTimeLabels = Object.keys(sleepTimeCategoryData).filter(k => sleepTimeCategoryData[k].length > 0);
            const sleepTimeStats = sleepTimeLabels.map(k => ({
                label: k,
                avg: sleepTimeCategoryData[k].reduce((a, b) => a + b, 0) / sleepTimeCategoryData[k].length,
                significant: useSignificance ? testCategorySignificance(sleepTimeCategoryData[k], allMoods, alpha) : true
            }));
            const sleepTimeAvgs = sleepTimeStats.map(s => s.avg);
            const sleepTimeColors = ['#4A5FD9', '#6B8EFF', '#9BB5FF', '#C4D7FF'].map((color, i) => {
                if (!sleepTimeStats[i]) return color;
                const alpha_opacity = useSignificance ? (sleepTimeStats[i].significant ? 1.0 : 0.3) : 1.0;
                const r = parseInt(color.slice(1,3), 16);
                const g = parseInt(color.slice(3,5), 16);
                const b = parseInt(color.slice(5,7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha_opacity})`;
            });
            
            if (sleepTimeLabels.length > 0) {
                const ctx3 = document.getElementById('sleepTimeCategoryChart').getContext('2d');
                sleepCharts.sleepTimeCategory = new Chart(ctx3, {
                    type: 'bar',
                    data: {
                        labels: sleepTimeLabels,
                        datasets: [{
                            label: 'Avg Mood',
                            data: sleepTimeAvgs,
                            backgroundColor: sleepTimeColors,
                            borderRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: { y: { min: 0, max: 5, ticks: { stepSize: 1 } } },
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (!useSignificance) return '';
                                        const stat = sleepTimeStats[context.dataIndex];
                                        return stat.significant ? `(Significant p<${alpha})` : '(Not significant)';
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // 4. Wake Time Category Chart
            const wakeTimeCategoryData = { 'Before 7AM': [], '7AM-8AM': [], '8AM-9AM': [], 'After 9AM': [] };
            sleepData.filter(d => d.wakeTime).forEach(d => {
                const [h] = d.wakeTime.split(':').map(Number);
                if (h < 7) wakeTimeCategoryData['Before 7AM'].push(d.mood);
                else if (h < 8) wakeTimeCategoryData['7AM-8AM'].push(d.mood);
                else if (h < 9) wakeTimeCategoryData['8AM-9AM'].push(d.mood);
                else wakeTimeCategoryData['After 9AM'].push(d.mood);
            });

            const wakeTimeLabels = Object.keys(wakeTimeCategoryData).filter(k => wakeTimeCategoryData[k].length > 0);
            const wakeTimeStats = wakeTimeLabels.map(k => ({
                label: k,
                avg: wakeTimeCategoryData[k].reduce((a, b) => a + b, 0) / wakeTimeCategoryData[k].length,
                significant: useSignificance ? testCategorySignificance(wakeTimeCategoryData[k], allMoods, alpha) : true
            }));
            const wakeTimeAvgs = wakeTimeStats.map(s => s.avg);
            const wakeTimeColors = ['#FFB84D', '#FFC97D', '#FFD9A1', '#FFE9C5'].map((color, i) => {
                if (!wakeTimeStats[i]) return color;
                const alpha_opacity = useSignificance ? (wakeTimeStats[i].significant ? 1.0 : 0.3) : 1.0;
                const r = parseInt(color.slice(1,3), 16);
                const g = parseInt(color.slice(3,5), 16);
                const b = parseInt(color.slice(5,7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha_opacity})`;
            });
            
            if (wakeTimeLabels.length > 0) {
                const ctx4 = document.getElementById('wakeTimeCategoryChart').getContext('2d');
                sleepCharts.wakeTimeCategory = new Chart(ctx4, {
                    type: 'bar',
                    data: {
                        labels: wakeTimeLabels,
                        datasets: [{
                            label: 'Avg Mood',
                            data: wakeTimeAvgs,
                            backgroundColor: wakeTimeColors,
                            borderRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: { y: { min: 0, max: 5, ticks: { stepSize: 1 } } },
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (!useSignificance) return '';
                                        const stat = wakeTimeStats[context.dataIndex];
                                        return stat.significant ? `(Significant p<${alpha})` : '(Not significant)';
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // 5. Sleep Consistency Chart - NEW CALCULATION METHOD
            if (scheduleData.length >= 7) {
                // Helper: Convert HH:MM to minutes from midnight
                const timeToMinutes = (timeStr) => {
                    const [h, m] = timeStr.split(':').map(Number);
                    let minutes = h * 60 + m;
                    // Handle overnight (times after midnight treated as next day)
                    if (h < 12) minutes += 24 * 60; // Sleep times before noon are likely evening
                    return minutes;
                };

                // Calculate daily consistency scores
                const dailyScores = [];
                
                for (let i = 0; i < scheduleData.length; i++) {
                    const today = scheduleData[i];
                    const todayBedtime = timeToMinutes(today.sleepTime);
                    const todayWaketime = timeToMinutes(today.wakeTime);
                    
                    // Need at least 7 previous days for moving average
                    if (i < 7) {
                        dailyScores.push({
                            date: today.date,
                            score: null,
                            bedtimeDev: null,
                            waketimeDev: null
                        });
                        continue;
                    }
                    
                    // Get previous 7 days (excluding today)
                    const prev7Days = scheduleData.slice(i - 7, i);
                    
                    // Calculate 7-day moving averages
                    const avgBedtime = prev7Days.reduce((sum, d) => sum + timeToMinutes(d.sleepTime), 0) / 7;
                    const avgWaketime = prev7Days.reduce((sum, d) => sum + timeToMinutes(d.wakeTime), 0) / 7;
                    
                    // Calculate deviations (in minutes)
                    const bedtimeDiff = Math.abs(todayBedtime - avgBedtime);
                    const waketimeDiff = Math.abs(todayWaketime - avgWaketime);
                    
                    // Calculate average daily deviation
                    const dailyDev = (bedtimeDiff + waketimeDiff) / 2;
                    
                    // Tiered scoring system
                    let dailyScore;
                    if (dailyDev <= 30) {
                        // Consistent: 100 down to 90
                        dailyScore = 100 - (dailyDev / 30) * 10;
                    } else if (dailyDev <= 90) {
                        // Moderate: 90 down to 60
                        dailyScore = 90 - ((dailyDev - 30) / 60) * 30;
                    } else {
                        // Inconsistent: 60 down to 0
                        dailyScore = Math.max(0, 60 - ((dailyDev - 90) / 90) * 60);
                    }
                    
                    dailyScores.push({
                        date: today.date,
                        score: dailyScore,
                        bedtimeDev: bedtimeDiff,
                        waketimeDev: waketimeDiff,
                        avgDev: dailyDev
                    });
                }
                
                // Filter out null scores
                const validScores = dailyScores.filter(s => s.score !== null);
                
                if (validScores.length > 0) {
                    // Calculate 7-day rolling average for final score
                    const last7Scores = validScores.slice(-Math.min(7, validScores.length));
                    const finalScore = last7Scores.reduce((sum, s) => sum + s.score, 0) / last7Scores.length;
                    
                    // Update stat display
                    document.getElementById('sleepConsistency').textContent = `${Math.round(finalScore)}%`;
                    
                    // 1. Gauge Chart (Circular Progress)
                    const gaugeCanvas = document.getElementById('sleepConsistencyGauge');
                    if (gaugeCanvas) {
                        const gaugeColor = finalScore >= 70 ? '#10b981' : finalScore >= 40 ? '#eab308' : '#ef4444';
                        
                        sleepCharts.consistencyGauge = new Chart(gaugeCanvas.getContext('2d'), {
                            type: 'doughnut',
                            data: {
                                datasets: [{
                                    data: [finalScore, 100 - finalScore],
                                    backgroundColor: [gaugeColor, '#e5e7eb'],
                                    borderWidth: 0,
                                    circumference: 180,
                                    rotation: 270
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: true,
                                cutout: '75%',
                                plugins: {
                                    legend: { display: false },
                                    tooltip: { enabled: false }
                                }
                            },
                            plugins: [{
                                id: 'centerText',
                                afterDraw: (chart) => {
                                    const ctx = chart.ctx;
                                    const centerX = chart.chartArea.left + (chart.chartArea.right - chart.chartArea.left) / 2;
                                    const centerY = chart.chartArea.top + (chart.chartArea.bottom - chart.chartArea.top) / 2 + 20;
                                    
                                    ctx.save();
                                    ctx.font = 'bold 32px Quicksand';
                                    ctx.fillStyle = gaugeColor;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText(`${Math.round(finalScore)}%`, centerX, centerY);
                                    
                                    ctx.font = '12px Quicksand';
                                    ctx.fillStyle = '#6b7280';
                                    ctx.fillText(finalScore >= 70 ? 'Consistent' : finalScore >= 40 ? 'Moderate' : 'Irregular', centerX, centerY + 25);
                                    ctx.restore();
                                }
                            }]
                        });
                    }
                    
                    // 2. Consistency Trend Chart (with period selection)
                    const ctx5 = document.getElementById('sleepConsistencyChart');
                    
                    if (ctx5 && validScores.length > 0) {
                        // Store data globally for period switching
                        window.sleepConsistencyData = validScores;
                        
                        // Render with default period (weekly)
                        renderConsistencyTrendChart('weekly');
                        
                        // Initialize button state
                        const chartCard = document.getElementById('sleepConsistencyChart').closest('.chart-card');
                        if (chartCard) {
                            chartCard.querySelectorAll('.period-btn').forEach(btn => {
                                btn.classList.remove('active');
                                if (btn.dataset.period === 'weekly') btn.classList.add('active');
                            });
                        }
                    }
                    
                    // 3. Sleep Time Consistency (bedtime only)
                    const sleepTimeScores = validScores.map(d => ({
                        date: d.date,
                        score: d.bedtimeDev <= 30 ? 100 - (d.bedtimeDev / 30) * 10 :
                               d.bedtimeDev <= 90 ? 90 - ((d.bedtimeDev - 30) / 60) * 30 :
                               Math.max(0, 60 - ((d.bedtimeDev - 90) / 90) * 60),
                        deviation: d.bedtimeDev
                    }));
                    
                    if (sleepTimeScores.length > 0) {
                        window.sleepTimeConsistencyData = sleepTimeScores;
                        const ctx7 = document.getElementById('sleepTimeConsistencyChart');
                        if (ctx7) {
                            renderSleepTimeConsistencyChart('weekly');
                            
                            // Initialize button state
                            const chartCard = document.getElementById('sleepTimeConsistencyChart').closest('.chart-card');
                            if (chartCard) {
                                chartCard.querySelectorAll('.period-btn').forEach(btn => {
                                    btn.classList.remove('active');
                                    if (btn.dataset.period === 'weekly') btn.classList.add('active');
                                });
                            }
                        }
                    }
                    
                    // 4. Wake Time Consistency (waketime only)
                    const wakeTimeScores = validScores.map(d => ({
                        date: d.date,
                        score: d.waketimeDev <= 30 ? 100 - (d.waketimeDev / 30) * 10 :
                               d.waketimeDev <= 90 ? 90 - ((d.waketimeDev - 30) / 60) * 30 :
                               Math.max(0, 60 - ((d.waketimeDev - 90) / 90) * 60),
                        deviation: d.waketimeDev
                    }));
                    
                    if (wakeTimeScores.length > 0) {
                        window.wakeTimeConsistencyData = wakeTimeScores;
                        const ctx8 = document.getElementById('wakeTimeConsistencyChart');
                        if (ctx8) {
                            renderWakeTimeConsistencyChart('weekly');
                            
                            // Initialize button state
                            const chartCard = document.getElementById('wakeTimeConsistencyChart').closest('.chart-card');
                            if (chartCard) {
                                chartCard.querySelectorAll('.period-btn').forEach(btn => {
                                    btn.classList.remove('active');
                                    if (btn.dataset.period === 'weekly') btn.classList.add('active');
                                });
                            }
                        }
                    }
                }
            }

            // 6. Sleep Quality Chart (reuse from Analytics)
            const sleepQualityData = {};
            sleepData.forEach(d => {
                if (d.sleep) {
                    if (!sleepQualityData[d.sleep]) sleepQualityData[d.sleep] = [];
                    sleepQualityData[d.sleep].push(d.mood);
                }
            });

            // Define custom sort order: Poor, Okay, Good, Great
            const qualityOrder = ['poor', 'okay', 'good', 'great'];
            
            const sleepQualityStats = Object.entries(sleepQualityData).map(([id, moods]) => ({
                id,
                label: userSettings.sleep.options.find(o => o.id === id)?.emoji + ' ' + userSettings.sleep.options.find(o => o.id === id)?.label || id,
                avg: moods.reduce((a, b) => a + b) / moods.length,
                significant: useSignificance ? testCategorySignificance(moods, allMoods, alpha) : true
            })).sort((a, b) => {
                // Sort by custom order
                const orderA = qualityOrder.indexOf(a.id.toLowerCase());
                const orderB = qualityOrder.indexOf(b.id.toLowerCase());
                if (orderA === -1 && orderB === -1) return 0;
                if (orderA === -1) return 1;
                if (orderB === -1) return -1;
                return orderA - orderB;
            });

            if (sleepQualityStats.length > 0) {
                const ctx6 = document.getElementById('sleepQualityChartSleep').getContext('2d');
                sleepCharts.sleepQuality = new Chart(ctx6, {
                    type: 'bar',
                    data: {
                        labels: sleepQualityStats.map(s => s.label),
                        datasets: [{
                            label: 'Avg Mood',
                            data: sleepQualityStats.map(s => s.avg),
                            backgroundColor: sleepQualityStats.map((stat, i) => {
                                // Color based on position: Poor=red, Okay=yellow, Good=lightgreen, Great=green
                                const colors = ['#ef4444', '#eab308', '#84cc16', '#22c55e'];
                                const alpha_opacity = useSignificance ? (stat.significant ? 1.0 : 0.3) : 1.0;
                                const color = colors[i] || '#6BCB77';
                                const r = parseInt(color.slice(1,3), 16);
                                const g = parseInt(color.slice(3,5), 16);
                                const b = parseInt(color.slice(5,7), 16);
                                return `rgba(${r}, ${g}, ${b}, ${alpha_opacity})`;
                            }),
                            borderRadius: 8
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                ticks: {
                                    autoSkip: false,
                                    font: { size: sleepQualityStats.length > 15 ? 8 : 11 }
                                }
                            },
                            y: { min: 0, max: 5, ticks: { stepSize: 1 } }
                        },
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (!useSignificance) return '';
                                        const stat = sleepQualityStats[context.dataIndex];
                                        return stat.significant ? `(Significant p<${alpha})` : '(Not significant)';
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            // 7. Sleep Consistency vs Mood - NEW
            // Categorize sleep consistency scores into bins
            if (window.sleepConsistencyData && window.sleepConsistencyData.length > 0) {
                const consistencyCategories = {
                    'Poor (0-59%)': [],
                    'Fair (60-89%)': [],
                    'Good (>90%)': []
                };
                
                // Match scores with moods based on date
                window.sleepConsistencyData.forEach(consistencyEntry => {
                    const matchingMood = sleepData.find(d => d.date === consistencyEntry.date);
                    if (matchingMood && matchingMood.mood) {
                        const score = consistencyEntry.score;
                        if (score > 90) {
                            consistencyCategories['Good (>90%)'].push(matchingMood.mood);
                        } else if (score >= 60) {
                            consistencyCategories['Fair (60-89%)'].push(matchingMood.mood);
                        } else {
                            consistencyCategories['Poor (0-59%)'].push(matchingMood.mood);
                        }
                    }
                });
                
                // Enforce order: Poor, Fair, Good
                const orderedCategories = ['Poor (0-59%)', 'Fair (60-89%)', 'Good (>90%)'];
                const consistencyLabels = orderedCategories.filter(k => consistencyCategories[k].length > 0);
                const consistencyStats = consistencyLabels.map(k => ({
                    label: k,
                    avg: consistencyCategories[k].reduce((a, b) => a + b, 0) / consistencyCategories[k].length,
                    significant: useSignificance ? testCategorySignificance(consistencyCategories[k], allMoods, alpha) : true
                }));
                const consistencyAvgs = consistencyStats.map(s => s.avg);
                // Colors: Poor (red), Fair (yellow), Good (green)
                const consistencyColorMap = {
                    'Poor (0-59%)': '#ef4444',
                    'Fair (60-89%)': '#eab308',
                    'Good (>90%)': '#10b981'
                };
                const consistencyColors = consistencyLabels.map(label => {
                    const stat = consistencyStats.find(s => s.label === label);
                    const alpha_opacity = useSignificance ? (stat.significant ? 1.0 : 0.3) : 1.0;
                    const color = consistencyColorMap[label];
                    const r = parseInt(color.slice(1,3), 16);
                    const g = parseInt(color.slice(3,5), 16);
                    const b = parseInt(color.slice(5,7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${alpha_opacity})`;
                });
                
                if (consistencyLabels.length > 0) {
                    const ctx7 = document.getElementById('sleepConsistencyVsMoodChart');
                    if (ctx7) {
                        sleepCharts.consistencyVsMood = new Chart(ctx7.getContext('2d'), {
                            type: 'bar',
                            data: {
                                labels: consistencyLabels,
                                datasets: [{
                                    label: 'Avg Mood',
                                    data: consistencyAvgs,
                                    backgroundColor: consistencyColors,
                                    borderRadius: 8
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: { 
                                    y: { 
                                        min: 0, 
                                        max: 5, 
                                        ticks: { stepSize: 1 } 
                                    } 
                                },
                                plugins: { 
                                    legend: { display: false },
                                    tooltip: {
                                        callbacks: {
                                            afterLabel: function(context) {
                                                if (!useSignificance) return '';
                                                const stat = consistencyStats[context.dataIndex];
                                                return stat.significant ? `(Significant p<${alpha})` : '(Not significant)';
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            }
            
            // 8. Sleep Duration vs Mood - Hourly Categories
            const sleepDurationData = sleepData.filter(d => d.sleepDuration);
            
            if (sleepDurationData.length > 0) {
                // Categorize by hour ranges
                const categories = {
                    '0-1 hrs': [],
                    '1-2 hrs': [],
                    '2-3 hrs': [],
                    '3-4 hrs': [],
                    '4-5 hrs': [],
                    '5-6 hrs': [],
                    '6-7 hrs': [],
                    '7-8 hrs': [],
                    '8-9 hrs': [],
                    '9-10 hrs': [],
                    '10-11 hrs': [],
                    '11-12 hrs': [],
                    '12+ hrs': []
                };
                
                sleepDurationData.forEach(d => {
                    const hours = d.sleepDuration / 60;
                    if (hours < 1) categories['0-1 hrs'].push(d.mood);
                    else if (hours < 2) categories['1-2 hrs'].push(d.mood);
                    else if (hours < 3) categories['2-3 hrs'].push(d.mood);
                    else if (hours < 4) categories['3-4 hrs'].push(d.mood);
                    else if (hours < 5) categories['4-5 hrs'].push(d.mood);
                    else if (hours < 6) categories['5-6 hrs'].push(d.mood);
                    else if (hours < 7) categories['6-7 hrs'].push(d.mood);
                    else if (hours < 8) categories['7-8 hrs'].push(d.mood);
                    else if (hours < 9) categories['8-9 hrs'].push(d.mood);
                    else if (hours < 10) categories['9-10 hrs'].push(d.mood);
                    else if (hours < 11) categories['10-11 hrs'].push(d.mood);
                    else if (hours < 12) categories['11-12 hrs'].push(d.mood);
                    else categories['12+ hrs'].push(d.mood);
                });
                
                // Calculate averages and significance (only for categories with data)
                const durationStats = Object.entries(categories)
                    .filter(([label, moods]) => moods.length > 0)
                    .map(([label, moods]) => ({
                        label,
                        avg: moods.reduce((a, b) => a + b, 0) / moods.length,
                        count: moods.length,
                        significant: useSignificance ? testCategorySignificance(moods, sleepData.map(d => d.mood), alpha) : true
                    }));
                
                if (durationStats.length > 0) {
                    const sleepDurationCanvas = document.getElementById('sleepDurationChart');
                    if (sleepDurationCanvas) {
                        sleepCharts.sleepDuration = new Chart(sleepDurationCanvas.getContext('2d'), {
                            type: 'bar',
                            data: {
                                labels: durationStats.map(s => s.label),
                                datasets: [{
                                    label: 'Avg Mood',
                                    data: durationStats.map(s => s.avg),
                                    backgroundColor: durationStats.map(stat => {
                                        const opacity = useSignificance ? (stat.significant ? 1.0 : 0.3) : 1.0;
                                        return `rgba(107, 203, 119, ${opacity})`; // Green
                                    }),
                                    borderRadius: 8
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: {
                                        min: 0,
                                        max: 5,
                                        ticks: { stepSize: 1 },
                                        title: { display: true, text: 'Avg Mood' }
                                    },
                                    x: {
                                        title: { display: true, text: 'Sleep Duration' }
                                    }
                                },
                                plugins: {
                                    legend: { display: false },
                                    tooltip: {
                                        callbacks: {
                                            afterLabel: function(context) {
                                                if (!useSignificance) return '';
                                                const stat = durationStats[context.dataIndex];
                                                return stat.significant ? `(Significant p<${alpha})` : '(Not significant)';
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            }
            
            // 9. Sleep Time vs Mood - Scatter Plot with Vertical Dash Lines
            const sleepTimeScatterData = sleepData
                .filter(d => d.sleepTime)
                .map(d => {
                    const [hours, minutes] = d.sleepTime.split(':').map(Number);
                    let timeDecimal = hours + minutes / 60;
                    if (timeDecimal < 12) timeDecimal += 24;
                    return { time: timeDecimal, mood: d.mood };
                });

            if (sleepTimeScatterData.length > 0) {
                const minTime = Math.min(...sleepTimeScatterData.map(d => d.time));
                const maxTime = Math.max(...sleepTimeScatterData.map(d => d.time));
                const xAxisMin = Math.floor(minTime) - 0.5;
                const xAxisMax = Math.ceil(maxTime) + 0.5;
                
                // Calculate average sleep time for each mood level
                const moodAverages = {};
                for (let mood = 1; mood <= 5; mood++) {
                    const moodEntries = sleepTimeScatterData.filter(d => d.mood === mood);
                    if (moodEntries.length > 0) {
                        const avgTime = moodEntries.reduce((sum, d) => sum + d.time, 0) / moodEntries.length;
                        moodAverages[mood] = avgTime;
                    }
                }
                
                // Create vertical line datasets for averages
                const averageLineDatasets = Object.entries(moodAverages).map(([mood, time]) => ({
                    label: `Mood ${mood} Average`,
                    data: [{ x: time, y: parseInt(mood) - 0.3 }, { x: time, y: parseInt(mood) + 0.3 }],
                    type: 'line',
                    borderColor: 'rgba(74, 95, 217, 1)',
                    borderWidth: 3,
                    pointRadius: 0,
                    fill: false,
                    tension: 0
                }));
                
                const scatterData = sleepTimeScatterData.map(d => ({ x: d.time, y: d.mood }));
                
                const sleepTimeCanvas = document.getElementById('sleepTimeChart');
                if (sleepTimeCanvas) {
                    sleepCharts.sleepTime = new Chart(sleepTimeCanvas.getContext('2d'), {
                        type: 'scatter',
                        data: {
                            datasets: [{
                                label: 'Sleep Time vs Mood',
                                data: scatterData,
                                backgroundColor: 'rgba(74, 95, 217, 0.6)',
                                borderColor: '#4A5FD9',
                                pointRadius: 6,
                                pointHoverRadius: 8
                            }, ...averageLineDatasets]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    title: { display: true, text: 'Sleep Time' },
                                    min: xAxisMin,
                                    max: xAxisMax,
                                    ticks: {
                                        stepSize: 0.5,
                                        callback: function(value) {
                                            const hour = value % 24;
                                            const hourInt = Math.floor(hour);
                                            const minutes = Math.round((hour % 1) * 60);
                                            const period = hourInt >= 12 ? 'PM' : 'AM';
                                            const displayHour = hourInt === 0 ? 12 : hourInt > 12 ? hourInt - 12 : hourInt;
                                            return minutes === 0 ? `${displayHour} ${period}` : `${displayHour}:${String(minutes).padStart(2, '0')} ${period}`;
                                        }
                                    }
                                },
                                y: {
                                    title: { display: true, text: 'Mood' },
                                    min: 0,
                                    max: 5.5,
                                    ticks: { stepSize: 1 }
                                }
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const value = context.parsed.x;
                                            const hour = Math.floor(value % 24);
                                            const minutes = Math.round((value % 1) * 60);
                                            const period = hour >= 12 ? 'PM' : 'AM';
                                            const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
                                            return `Sleep: ${displayHour}:${String(minutes).padStart(2, '0')} ${period}, Mood: ${context.parsed.y}`;
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            }
            
            // 10. Wake Time vs Mood - Scatter Plot with Vertical Dash Lines
            const wakeTimeScatterData = sleepData
                .filter(d => d.wakeTime)
                .map(d => {
                    const [hours, minutes] = d.wakeTime.split(':').map(Number);
                    let timeDecimal = hours + minutes / 60;
                    return { time: timeDecimal, mood: d.mood };
                });

            if (wakeTimeScatterData.length > 0) {
                const minTime = Math.min(...wakeTimeScatterData.map(d => d.time));
                const maxTime = Math.max(...wakeTimeScatterData.map(d => d.time));
                const xAxisMin = Math.floor(minTime) - 0.5;
                const xAxisMax = Math.ceil(maxTime) + 0.5;
                
                // Calculate average wake time for each mood level
                const moodAverages = {};
                for (let mood = 1; mood <= 5; mood++) {
                    const moodEntries = wakeTimeScatterData.filter(d => d.mood === mood);
                    if (moodEntries.length > 0) {
                        const avgTime = moodEntries.reduce((sum, d) => sum + d.time, 0) / moodEntries.length;
                        moodAverages[mood] = avgTime;
                    }
                }
                
                // Create vertical line datasets for averages
                const averageLineDatasets = Object.entries(moodAverages).map(([mood, time]) => ({
                    label: `Mood ${mood} Average`,
                    data: [{ x: time, y: parseInt(mood) - 0.3 }, { x: time, y: parseInt(mood) + 0.3 }],
                    type: 'line',
                    borderColor: 'rgba(255, 184, 77, 1)',
                    borderWidth: 3,
                    pointRadius: 0,
                    fill: false,
                    tension: 0
                }));
                
                const scatterData = wakeTimeScatterData.map(d => ({ x: d.time, y: d.mood }));
                
                const wakeTimeCanvas = document.getElementById('wakeTimeChart');
                if (wakeTimeCanvas) {
                    sleepCharts.wakeTime = new Chart(wakeTimeCanvas.getContext('2d'), {
                        type: 'scatter',
                        data: {
                            datasets: [{
                                label: 'Wake Time vs Mood',
                                data: scatterData,
                                backgroundColor: 'rgba(255, 184, 77, 0.6)',
                                borderColor: '#FFB84D',
                                pointRadius: 6,
                                pointHoverRadius: 8
                            }, ...averageLineDatasets]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    title: { display: true, text: 'Wake Time' },
                                    min: xAxisMin,
                                    max: xAxisMax,
                                    ticks: {
                                        stepSize: 1,
                                        callback: function(value) {
                                            const hour = value;
                                            const period = hour >= 12 ? 'PM' : 'AM';
                                            const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
                                            return `${Math.floor(displayHour)} ${period}`;
                                        }
                                    }
                                },
                                y: {
                                    title: { display: true, text: 'Mood' },
                                    min: 0,
                                    max: 5.5,
                                    ticks: { stepSize: 1 }
                                }
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            const value = context.parsed.x;
                                            const hourInt = Math.floor(value);
                                            const minutes = Math.round((value % 1) * 60);
                                            const period = hourInt >= 12 ? 'PM' : 'AM';
                                            const displayHour = hourInt === 0 ? 12 : hourInt > 12 ? hourInt - 12 : hourInt;
                                            return `Wake: ${displayHour}:${String(minutes).padStart(2, '0')} ${period}, Mood: ${context.parsed.y}`;
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            }
        }

        applySleepDateRangeBtn.addEventListener('click', () => {
            loadSleepData(sleepStartDateInput.value, sleepEndDateInput.value);
        });

        // Set default dates for sleep tab (same as Analytics)
        async function setDefaultSleepDates() {
            try {
                const allDates = await getAllMoodData('2020-01-01', today.toISOString().split('T')[0]);
                if (allDates.length > 0) {
                    allDates.sort((a, b) => new Date(a.date) - new Date(b.date));
                    sleepStartDateInput.value = allDates[0].date;
                    sleepEndDateInput.value = allDates[allDates.length - 1].date;
                } else {
                    // No data, use defaults
                    const threeMonthsAgo = new Date(today);
                    threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
                    sleepStartDateInput.value = threeMonthsAgo.toISOString().split('T')[0];
                    sleepEndDateInput.value = today.toISOString().split('T')[0];
                }
            } catch (error) {
                const threeMonthsAgo = new Date(today);
                threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
                sleepStartDateInput.value = threeMonthsAgo.toISOString().split('T')[0];
                sleepEndDateInput.value = today.toISOString().split('T')[0];
            }
        }

        async function setDefaultRecordDates() {
            try {
                const allDates = await getAllMoodData('2020-01-01', today.toISOString().split('T')[0]);
                if (allDates.length > 0) {
                    allDates.sort((a, b) => new Date(a.date) - new Date(b.date));
                    recordStartDateInput.value = allDates[0].date;
                    recordEndDateInput.value = allDates[allDates.length - 1].date;
                } else {
                    const threeMonthsAgo = new Date(today);
                    threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
                    recordStartDateInput.value = threeMonthsAgo.toISOString().split('T')[0];
                    recordEndDateInput.value = today.toISOString().split('T')[0];
                }
            } catch (error) {
                const threeMonthsAgo = new Date(today);
                threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
                recordStartDateInput.value = threeMonthsAgo.toISOString().split('T')[0];
                recordEndDateInput.value = today.toISOString().split('T')[0];
            }
        }

        // Render Consistency Trend Chart with different time periods
        function renderConsistencyTrendChart(period) {
            if (!window.sleepConsistencyData || window.sleepConsistencyData.length === 0) return;
            
            const data = window.sleepConsistencyData;
            let aggregatedData = [];
            
            if (period === 'daily') {
                // Show all daily data
                aggregatedData = data.map(d => ({
                    label: new Date(d.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                    score: d.score,
                    bedtimeDev: d.bedtimeDev,
                    waketimeDev: d.waketimeDev
                }));
            } else if (period === 'weekly') {
                // Group by week and average
                const weeks = {};
                data.forEach(d => {
                    const date = new Date(d.date);
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay()); // Start of week (Sunday)
                    const weekKey = weekStart.toISOString().split('T')[0];
                    
                    if (!weeks[weekKey]) {
                        weeks[weekKey] = { scores: [], bedtimeDevs: [], waketimeDevs: [], date: weekStart };
                    }
                    weeks[weekKey].scores.push(d.score);
                    weeks[weekKey].bedtimeDevs.push(d.bedtimeDev);
                    weeks[weekKey].waketimeDevs.push(d.waketimeDev);
                });
                
                aggregatedData = Object.entries(weeks).map(([key, week]) => ({
                    label: week.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                    score: week.scores.reduce((a, b) => a + b, 0) / week.scores.length,
                    bedtimeDev: week.bedtimeDevs.reduce((a, b) => a + b, 0) / week.bedtimeDevs.length,
                    waketimeDev: week.waketimeDevs.reduce((a, b) => a + b, 0) / week.waketimeDevs.length
                })).sort((a, b) => new Date(a.label) - new Date(b.label));
            } else if (period === 'monthly') {
                // Group by month and average
                const months = {};
                data.forEach(d => {
                    const date = new Date(d.date);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    
                    if (!months[monthKey]) {
                        months[monthKey] = { scores: [], bedtimeDevs: [], waketimeDevs: [], date: new Date(date.getFullYear(), date.getMonth(), 1) };
                    }
                    months[monthKey].scores.push(d.score);
                    months[monthKey].bedtimeDevs.push(d.bedtimeDev);
                    months[monthKey].waketimeDevs.push(d.waketimeDev);
                });
                
                aggregatedData = Object.entries(months).map(([key, month]) => ({
                    label: month.date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }),
                    score: month.scores.reduce((a, b) => a + b, 0) / month.scores.length,
                    bedtimeDev: month.bedtimeDevs.reduce((a, b) => a + b, 0) / month.bedtimeDevs.length,
                    waketimeDev: month.waketimeDevs.reduce((a, b) => a + b, 0) / month.waketimeDevs.length
                })).sort((a, b) => new Date(a.label) - new Date(b.label));
            }
            
            // Destroy existing chart if it exists
            if (sleepCharts.consistency) {
                sleepCharts.consistency.destroy();
            }
            
            const ctx = document.getElementById('sleepConsistencyChart');
            if (ctx) {
                sleepCharts.consistency = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: aggregatedData.map(d => d.label),
                        datasets: [{
                            label: 'Consistency Score',
                            data: aggregatedData.map(d => d.score),
                            borderColor: '#6BCB77',
                            backgroundColor: 'rgba(107, 203, 119, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 5,
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                min: 0,
                                max: 100,
                                ticks: { 
                                    stepSize: 20,
                                    callback: v => v + '%'
                                },
                                title: {
                                    display: true,
                                    text: 'Consistency Score (%)'
                                }
                            },
                            x: {
                                ticks: {
                                    maxTicksLimit: period === 'daily' ? 10 : period === 'weekly' ? 12 : 12
                                },
                                title: {
                                    display: true,
                                    text: period === 'daily' ? 'Date' : period === 'weekly' ? 'Week Starting' : 'Month'
                                }
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const idx = context.dataIndex;
                                        const d = aggregatedData[idx];
                                        return [
                                            `Score: ${Math.round(d.score)}%`,
                                            `Bedtime Dev: ${Math.round(d.bedtimeDev)} min`,
                                            `Waketime Dev: ${Math.round(d.waketimeDev)} min`
                                        ];
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Update consistency chart period (global function for onclick)
        window.updateConsistencyPeriod = function(period) {
            // Only update buttons for this specific chart
            const chartCard = document.getElementById('sleepConsistencyChart').closest('.chart-card');
            chartCard.querySelectorAll('.period-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.period === period) {
                    btn.classList.add('active');
                }
            });
            
            // Re-render chart
            renderConsistencyTrendChart(period);
        };
        
        // Render Sleep Time Consistency Chart
        function renderSleepTimeConsistencyChart(period) {
            if (!window.sleepTimeConsistencyData) return;
            
            const data = window.sleepTimeConsistencyData;
            const aggregatedData = aggregateConsistencyData(data, period, 'deviation');
            
            if (sleepCharts.sleepTimeConsistency) {
                sleepCharts.sleepTimeConsistency.destroy();
            }
            
            const ctx = document.getElementById('sleepTimeConsistencyChart');
            if (ctx) {
                sleepCharts.sleepTimeConsistency = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: aggregatedData.map(d => d.label),
                        datasets: [{
                            label: 'Bedtime Consistency',
                            data: aggregatedData.map(d => d.score),
                            borderColor: '#4A5FD9',
                            backgroundColor: 'rgba(74, 95, 217, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 5,
                            borderWidth: 2
                        }],
                        _aggregated: aggregatedData  // Store for tooltip access
                    },
                    options: getConsistencyChartOptions(period, 'Bedtime Deviation')
                });
            }
        }
        
        // Render Wake Time Consistency Chart
        function renderWakeTimeConsistencyChart(period) {
            if (!window.wakeTimeConsistencyData) return;
            
            const data = window.wakeTimeConsistencyData;
            const aggregatedData = aggregateConsistencyData(data, period, 'deviation');
            
            if (sleepCharts.wakeTimeConsistency) {
                sleepCharts.wakeTimeConsistency.destroy();
            }
            
            const ctx = document.getElementById('wakeTimeConsistencyChart');
            if (ctx) {
                sleepCharts.wakeTimeConsistency = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: aggregatedData.map(d => d.label),
                        datasets: [{
                            label: 'Wake Time Consistency',
                            data: aggregatedData.map(d => d.score),
                            borderColor: '#FFB84D',
                            backgroundColor: 'rgba(255, 184, 77, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 5,
                            borderWidth: 2
                        }],
                        _aggregated: aggregatedData  // Store for tooltip access
                    },
                    options: getConsistencyChartOptions(period, 'Waketime Deviation')
                });
            }
        }
        
        // Helper: Aggregate consistency data by period
        function aggregateConsistencyData(data, period, devField) {
            let aggregated = [];
            
            if (period === 'daily') {
                aggregated = data.map(d => ({
                    label: new Date(d.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                    score: d.score,
                    deviation: d[devField]
                }));
            } else if (period === 'weekly') {
                const weeks = {};
                data.forEach(d => {
                    const date = new Date(d.date);
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay());
                    const weekKey = weekStart.toISOString().split('T')[0];
                    
                    if (!weeks[weekKey]) {
                        weeks[weekKey] = { scores: [], deviations: [], date: weekStart };
                    }
                    weeks[weekKey].scores.push(d.score);
                    weeks[weekKey].deviations.push(d[devField]);
                });
                
                aggregated = Object.entries(weeks).map(([key, week]) => ({
                    label: week.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                    score: week.scores.reduce((a, b) => a + b, 0) / week.scores.length,
                    deviation: week.deviations.reduce((a, b) => a + b, 0) / week.deviations.length
                }));
            } else if (period === 'monthly') {
                const months = {};
                data.forEach(d => {
                    const date = new Date(d.date);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    
                    if (!months[monthKey]) {
                        months[monthKey] = { scores: [], deviations: [], date: new Date(date.getFullYear(), date.getMonth(), 1) };
                    }
                    months[monthKey].scores.push(d.score);
                    months[monthKey].deviations.push(d[devField]);
                });
                
                aggregated = Object.entries(months).map(([key, month]) => ({
                    label: month.date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }),
                    score: month.scores.reduce((a, b) => a + b, 0) / month.scores.length,
                    deviation: month.deviations.reduce((a, b) => a + b, 0) / month.deviations.length
                }));
            }
            
            return aggregated;
        }
        
        // Helper: Get chart options for consistency charts
        function getConsistencyChartOptions(period, deviationLabel) {
            return {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        min: 0,
                        max: 100,
                        ticks: { 
                            stepSize: 20,
                            callback: v => v + '%'
                        },
                        title: {
                            display: true,
                            text: 'Consistency Score (%)'
                        }
                    },
                    x: {
                        ticks: {
                            maxTicksLimit: period === 'daily' ? 10 : 12
                        },
                        title: {
                            display: true,
                            text: period === 'daily' ? 'Date' : period === 'weekly' ? 'Week Starting' : 'Month'
                        }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const idx = context.dataIndex;
                                const d = context.chart.data.datasets[0].data[idx];
                                const aggregated = context.chart.config._config.data._aggregated;
                                return [
                                    `Score: ${Math.round(d)}%`,
                                    `${deviationLabel}: ${Math.round(aggregated[idx].deviation)} min`
                                ];
                            }
                        }
                    }
                }
            };
        }
        
        // Update period functions (global)
        window.updateSleepTimeConsistencyPeriod = function(period) {
            // Only update buttons for this specific chart
            const chartCard = document.getElementById('sleepTimeConsistencyChart').closest('.chart-card');
            chartCard.querySelectorAll('.period-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.period === period) btn.classList.add('active');
            });
            renderSleepTimeConsistencyChart(period);
        };
        
        window.updateWakeTimeConsistencyPeriod = function(period) {
            // Only update buttons for this specific chart
            const chartCard = document.getElementById('wakeTimeConsistencyChart').closest('.chart-card');
            chartCard.querySelectorAll('.period-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.period === period) btn.classList.add('active');
            });
            renderWakeTimeConsistencyChart(period);
        };
        
        // Render Mood Consistency Chart
        function renderMoodConsistencyChart(period) {
            if (!window.moodConsistencyData) return;
            
            const data = window.moodConsistencyData;
            let aggregatedData = [];
            
            if (period === 'daily') {
                aggregatedData = data.map(d => ({
                    label: new Date(d.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                    score: d.score,
                    deviation: d.deviation
                }));
            } else if (period === 'weekly') {
                const weeks = {};
                data.forEach(d => {
                    const date = new Date(d.date);
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay());
                    const weekKey = weekStart.toISOString().split('T')[0];
                    
                    if (!weeks[weekKey]) {
                        weeks[weekKey] = { scores: [], deviations: [], date: weekStart };
                    }
                    weeks[weekKey].scores.push(d.score);
                    weeks[weekKey].deviations.push(d.deviation);
                });
                
                aggregatedData = Object.entries(weeks).map(([key, week]) => ({
                    label: week.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                    score: week.scores.reduce((a, b) => a + b, 0) / week.scores.length,
                    deviation: week.deviations.reduce((a, b) => a + b, 0) / week.deviations.length
                }));
            } else if (period === 'monthly') {
                const months = {};
                data.forEach(d => {
                    const date = new Date(d.date);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    
                    if (!months[monthKey]) {
                        months[monthKey] = { scores: [], deviations: [], date: new Date(date.getFullYear(), date.getMonth(), 1) };
                    }
                    months[monthKey].scores.push(d.score);
                    months[monthKey].deviations.push(d.deviation);
                });
                
                aggregatedData = Object.entries(months).map(([key, month]) => ({
                    label: month.date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }),
                    score: month.scores.reduce((a, b) => a + b, 0) / month.scores.length,
                    deviation: month.deviations.reduce((a, b) => a + b, 0) / month.deviations.length
                }));
            }
            
            if (charts.moodConsistency) {
                charts.moodConsistency.destroy();
            }
            
            const ctx = document.getElementById('moodConsistencyChart');
            if (ctx) {
                charts.moodConsistency = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: aggregatedData.map(d => d.label),
                        datasets: [{
                            label: 'Mood Consistency',
                            data: aggregatedData.map(d => d.score),
                            borderColor: '#FF9B71',
                            backgroundColor: 'rgba(255, 155, 113, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 5,
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                min: 0,
                                max: 100,
                                ticks: { 
                                    stepSize: 20,
                                    callback: v => v + '%'
                                },
                                title: {
                                    display: true,
                                    text: 'Consistency Score (%)'
                                }
                            },
                            x: {
                                ticks: {
                                    maxTicksLimit: period === 'daily' ? 10 : 12
                                },
                                title: {
                                    display: true,
                                    text: period === 'daily' ? 'Date' : period === 'weekly' ? 'Week Starting' : 'Month'
                                }
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const idx = context.dataIndex;
                                        const d = aggregatedData[idx];
                                        return [
                                            `Score: ${Math.round(d.score)}%`,
                                            `Avg Deviation: ${d.deviation.toFixed(2)} mood points`
                                        ];
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
        
        window.updateMoodConsistencyPeriod = function(period) {
            // Only update buttons for this specific chart
            const chartCard = document.getElementById('moodConsistencyChart').closest('.chart-card');
            chartCard.querySelectorAll('.period-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.period === period) btn.classList.add('active');
            });
            renderMoodConsistencyChart(period);
        };

        // Info icon click handling for mobile
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.info-icon').forEach(icon => {
                icon.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const message = this.getAttribute('title');
                    if (message) {
                        alert(message);
                    }
                });
            });
        });

        // ============================================
        // WAITLIST FUNCTIONALITY
        // ============================================
        const waitlistModal = document.getElementById('waitlistModal');
        const waitlistBannerBtn = document.getElementById('waitlistBannerBtn');
        const waitlistClose = document.getElementById('waitlistClose');
        const waitlistForm = document.getElementById('waitlistForm');
        const waitlistEmail = document.getElementById('waitlistEmail');
        const waitlistSubmit = document.getElementById('waitlistSubmit');
        const waitlistMessage = document.getElementById('waitlistMessage');

        // Open waitlist modal
        function openWaitlistModal() {
            waitlistModal.classList.add('show');
            waitlistEmail.focus();
        }

        // Close waitlist modal
        function closeWaitlistModal() {
            waitlistModal.classList.remove('show');
            waitlistMessage.textContent = '';
            waitlistMessage.className = 'waitlist-message';
        }

        // Event listeners for waitlist
        if (waitlistBannerBtn) {
            waitlistBannerBtn.addEventListener('click', openWaitlistModal);
        }

        if (waitlistClose) {
            waitlistClose.addEventListener('click', closeWaitlistModal);
        }

        // Close modal on outside click
        if (waitlistModal) {
            waitlistModal.addEventListener('click', (e) => {
                if (e.target === waitlistModal) {
                    closeWaitlistModal();
                }
            });
        }

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && waitlistModal.classList.contains('show')) {
                closeWaitlistModal();
            }
        });

        // Handle waitlist form submission
        if (waitlistForm) {
            waitlistForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const email = waitlistEmail.value.trim();
                if (!email) return;

                // Disable button and show loading state
                waitlistSubmit.disabled = true;
                waitlistSubmit.textContent = 'Submitting...';
                waitlistMessage.textContent = '';
                waitlistMessage.className = 'waitlist-message';

                try {
                    // Save to Firestore waitlist collection
                    const waitlistDocRef = doc(db, 'waitlist', email);
                    await setDoc(waitlistDocRef, {
                        email: email,
                        signedUpAt: new Date().toISOString(),
                        source: 'demo_page',
                        userAgent: navigator.userAgent
                    });

                    // Show success message
                    waitlistMessage.innerHTML = '<span class="waitlist-success-icon">âœ“</span> You\'re on the list! We\'ll notify you when we launch.';
                    waitlistMessage.className = 'waitlist-message success';
                    waitlistEmail.value = '';
                    waitlistSubmit.textContent = 'You\'re In! ðŸŽ‰';

                    // Close modal after 3 seconds
                    setTimeout(() => {
                        closeWaitlistModal();
                        waitlistSubmit.textContent = 'Notify Me ðŸ””';
                        waitlistSubmit.disabled = false;
                    }, 3000);

                } catch (error) {
                    console.error('Waitlist error:', error);
                    
                    // Check if it's a duplicate email (document already exists)
                    if (error.code === 'permission-denied') {
                        waitlistMessage.textContent = 'This email is already on the list! ðŸ‘';
                        waitlistMessage.className = 'waitlist-message success';
                    } else {
                        waitlistMessage.textContent = 'Something went wrong. Please try again.';
                        waitlistMessage.className = 'waitlist-message error';
                    }
                    
                    waitlistSubmit.textContent = 'Notify Me ðŸ””';
                    waitlistSubmit.disabled = false;
                }
            });
        }
        // ============================================

        // Initialize
        initAuth();
    </script>
</body>
</html>
